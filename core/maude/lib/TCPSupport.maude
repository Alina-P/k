--- syntax used by the tcp interface and the tcp backend
mod #TCP-SYNTAX is
	including #SOCKET .
	
	op error : -> #String .
	op containedRequest : #Socket-Configuration -> [#String] .
	op toSend : #String -> #Socket-Msg .
	op start : #Nat -> #Socket-Configuration .
	op tcpRequest : #String -> #String .
endm

mod #TCP-CLIENT is
	including #TCP-SYNTAX .
	
	sort #TCPState .
		
	op Client : -> #Socket-Cid .
	op cnum : #Nat -> #Socket-Oid .
	
	ops idle connecting sending receiving haveAnswer closing connected finished : -> #TCPState [ctor] .
	
	op state:_ : #TCPState -> #Socket-Attribute [ctor] .
	op answer:_ : #String -> #Socket-Attribute [ctor] .
	op connectedTo:_ : #Socket-Oid -> #Socket-Attribute [ctor] .
	
		
	vars Me Server : #Socket-Oid .
	var A : #Socket-AttributeSet .
	var S : #String .
	var M : #Socket-Msg .
	var C : #Socket-Configuration .
	var N : #Nat .
	
	rl < Me : Client | state: connecting,#Socket A > #Socket createdSocket(Me, socketManager, Server)
	=> < Me : Client | state: connected,#Socket connectedTo: Server,#Socket A >
	[print "connected"] .
	
	----- errors
	eq containedRequest(C #Socket socketError(Me, socketManager, S))
	= error
	[print "socket error: " S] .
	eq containedRequest(C #Socket < Me : Client | state: connecting,#Socket  A > #Socket closedSocket(Me, Server, S))
	= error
	[print "error connecting: " S] .
	eq containedRequest(C #Socket < Me : Client | state: receiving,#Socket  A > #Socket closedSocket(Me, Server, S))
	= error
	[print "error receiving: " S] .
	-----
	
	rl < Me : Client | state: connected,#Socket  connectedTo: Server,#Socket  A > #Socket toSend(S)
	=> < Me : Client | state: sending,#Socket  connectedTo: Server,#Socket  A > #Socket send(Server, Me, S)
	[print "sending"] .
	
	rl < Me : Client | state: sending,#Socket  A > #Socket sent(Me, Server)
	=> < Me : Client | state: receiving,#Socket  A > #Socket receive(Server, Me)
	[print "receiving"] .
	
	rl < Me : Client | state: receiving,#Socket  A > #Socket received(Me, Server, S)
	=> < Me : Client | state: haveAnswer,#Socket  answer: S,#Socket  A >
	[print "have answer"] .
	
	rl < Me : Client | state: haveAnswer,#Socket  connectedTo: Server,#Socket  A > 
	=> < Me : Client | state: closing,#Socket  connectedTo: Server,#Socket  A > #Socket closeSocket(Server, Me)
	[print "closing"] .
	
	rl < Me : Client | state: closing,#Socket  A  > #Socket closedSocket(Me, Server, S)
	=> < Me : Client | state: finished,#Socket  A  >
	[print "finished"] .
	
	rl containedRequest(C #Socket < Me : Client | state: finished,#Socket  answer: S,#Socket  A  >)
	=> S
	[print "popping out of socket stuff"] .
	
	rl start(N) => 
		<> #Socket
		< cnum(N) : Client | state: connecting > #Socket
		createClientTcpSocket(socketManager, cnum(N), "localhost", 10000) .

endm

mod #TCP-INTERFACE is
	including #TCP-SYNTAX .
	including #TCP-CLIENT .
	including #COUNTER .
		
	
	op errorTCPSyntax : #String -> #String .
	eq tcpRequest(S:#String) = check(containedRequest(start(counter) #Socket toSend(S:#String +String "\r\n"))) .

	op check : #String -> #String .
	op getTCPData : #String -> #String .


	ceq check(S:#String) = getTCPData(substrString(S:#String, lengthString("success#"), lengthString(S:#String)))
		if substrString(S:#String, 0, lengthString("success#")) ==Bool "success#" [print "full output: " S:#String] .

        ceq getTCPData(S:#String)
          = substrString(S:#String, 0, N:#Nat)
         if N:#Nat := findString(S:#String, "###", 0) .

         eq getTCPData(S:#String)
          = errorTCPSyntax("Incorrect Output: " +String S:#String) .
		
	ceq check(S:#String) = errorTCPSyntax(getTCPData(substrString(S:#String, lengthString("fail#"), lengthString(S:#String))))
		if substrString(S:#String, 0, lengthString("fail#")) ==Bool "fail#" [print "full error string: " S:#String] .
		
	eq check("") = errorTCPSyntax("Unknown error") .
	eq check(error) = errorTCPSyntax("Unknown error") .

       op #isTCPError : #String -> #Bool .
       eq #isTCPError(errorTCPSyntax(S:#String)) = true .
       eq #isTCPError(S:#String) = false [owise] .
endm
