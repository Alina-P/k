mod STRICTCXT2EQS is
  including K-SORTS .
  including K-META-OPS .
  including STRICT-ATTRS .
  including K-STRICTNESS-OPS .
  including META-TERM-EXTRAS .
  including STRING-EXTRAS .
  including META-MODULE-EXTRAS .
  including META-K-MODULE .
  including META-K-CONTEXTS .
  including META-K-COOL .
  including META-K-RULES .
  including METADATA-EXTRAS .
  including COMPILATION-ATTRS .
  including META-K-WRAPPERS .
  var T : Term . var V : Variable .  var Trl : TermList . 
  var Sort S : Sort .  var Ss : SortSet .
  var AS AS' AS'' : AttrSet . var A : Attr .
  var MAS : MembAxSet . var Mb : MembAx .
  var Eqs Eqs' : EquationSet . var Rls Rls' : RuleSet . var Q : Qid .
  vars Type Type' : Type .  var OPDS : OpDeclSet . var KCS : KContextSplit .
  vars T1 T2 : Term . var Cond : TermList .  var Cnd : Condition .
  sort MASEqsPair .

---(
  op coolOps : -> OpDeclSet .
  eq coolOps 
   = (op 'cool : K -> K [none] .) 
     (op mkKLabel('heat) : nil -> KLabel [none] .)
     (op mkKLabel('redex) : nil -> KLabel [none] .)
  .
---)

  op defaultCoolEqs : SortSet -> EquationSet .
  eq defaultCoolEqs(S ; Ss)
   = (ceq mkCell(S, kra(mkVariable('K,NeK),kApply(heatLabel,empty),mkVariable('K',K))) 
       = mkCell(S, kra(mkVariable('K,NeK),mkVariable('K',K))) 
       if makeKCondition(strictCondTerm(mkVariable('K,NeK), S))
      [metadata(pair("cool","skip-heat"))] .)
    (eq mkCell(cool(S), kra(mkVariable('K,K),kApply(heatLabel,empty),mkVariable('K',K))) 
       = mkCell(S, 'cool[kra(mkVariable('K,K),kApply(heatLabel,empty),mkVariable('K',K))]) 
      [metadata(pair("supercool","start"))] .)
     (eq mkCell(cool(S), mkVariable('K,K)) 
       = mkCell(S, mkVariable('K,K)) 
      [owise metadata(pair("supercool","skip"))] .)
     defaultCoolEqs(Ss) .
  eq defaultCoolEqs(none) 
   = (ceq 'cool[kra(mkVariable('K,K),kApply(heatLabel,empty),mkVariable('K',K))]
        = 'cool[kra(mkVariable('K,K),mkVariable('K',K))]
       if 'inKList[kApply(heatLabel,empty),mkVariable('K,K)] = falseCt
      [owise metadata(pair("supercool","skip-heat"))] .)
     (eq 'cool[mkVariable('zk,K)] = mkVariable('zk,K) 
      [owise metadata(pair("supercool","end"))] .) .

---(
  op defaultHeatRules : -> RuleSet .
  eq defaultHeatRules
   = (rl kApply(mkConstant(mkKLabel('heat),KLabel),(mkVariable('K1,KList),kApply(mkConstant(mkKLabel('redex),KLabel), mkVariable('K,K)), mkVariable('K2,KList))) => kra(mkVariable('K,K), kApply(mkConstant(mkKLabel('heat),KLabel),empty)) [metadata(pair("superheat","choice"))] .) .
---)

  op {_,_,_} : MembAxSet EquationSet RuleSet -> MASEqsPair [ctor] .

  op strictCxt2eqs : Module MembAxSet AttrSet ~> MASEqsPair .
  eq strictCxt2eqs(M,MAS, AS) = strictCxt2eqs(M, MAS, none, none, AS) .
  op strictCxt2eqs : Module MembAxSet EquationSet RuleSet AttrSet ~> MASEqsPair . 
 ceq strictCxt2eqs(M, Mb MAS, Eqs, Rls, AS)
   = strictCxt2eq(M, MAS, Eqs, Rls, pReplaceCxt(T,1),pReplaceCxt(T,2), getAttrs(KCS), getCondition(KCS), AS)
  if KCS := splitKContext(Mb) /\ T := getContents(KCS) .
  eq strictCxt2eqs(M, MAS,Eqs, Rls, AS) = {MAS,Eqs, Rls} [owise] . 

  op strictCxt2eq : Module MembAxSet EquationSet RuleSet Term Term AttrSet TermList AttrSet ~> MASEqsPair .
  eq strictCxt2eq(M, MAS, Eqs, Rls, T1, T2, kstrict(nil,Q) AS, Cond, AS') 
   = strictCxt2eqs(M, MAS, Eqs coolingEqs(M, T1, T2, Q, AS), Rls, heating(M, T1, T2, Q, Cond, AS, AS'), AS') .

  eq strictCxt2eq(M, MAS, Eqs, Rls, T1, T2, AS, Cond, AS')
   = strictCxt2eq(M, MAS, Eqs, Rls, T1, T2, kstrict(nil,klabel) AS, Cond, AS') [owise] .

  op strictCxt2eqs : Module MembAxSet EquationSet RuleSet MASEqsPair AttrSet ~> MASEqsPair . 
  eq strictCxt2eqs(M, MAS, Eqs, Rls, {none, Eqs', Rls'}, AS)
   = strictCxt2eqs(M, MAS, Eqs Eqs', Rls Rls', AS) [print "Eqs: " Eqs' " and Rls: " Rls'] .
   
  
  op heating : Module Term Term Qid TermList AttrSet AttrSet -> MASEqsPair .
 ceq heating(M, T1, T2, Q, Cond, AS, AS')
   = {none, heatEqs(Q, T1[hole <- mkVariable('Kcxt,NeK)], kra(mkVariable('Kcxt,NeK), freezeTerm(M, T1)), makeKCondition(andBool(strictCond(mkVariable('Kcxt,NeK),Q),Cond[hole <- mkVariable('Kcxt,NeK)])), AS, AS'), none} if T2 = hole .
  eq heating(M, T1, T2, Q, Cond, AS, AS')
   = {none, 
    (eq T2[hole <- T2[hole <- mkVariable('KCxt,K)]] = T2[hole <- mkVariable('KCxt,K)] [metadata(pair("heating","idem"))] .)
    heatEqs(Q, T1[hole <- kApply(mkVariable('KcxtL,KLabel),mkVariable('Kcxt,KList))], kra(T2[hole <- kApply(mkVariable('KcxtL,KLabel),mkVariable('Kcxt,KList))], freezeTerm(M, T1)), makeKCondition(andBool(strictCond(kApply(mkVariable('KcxtL,KLabel),mkVariable('Kcxt,KList)),Q),Cond[hole <- kApply(mkVariable('KcxtL,KLabel),mkVariable('Kcxt,KList))])), AS, AS'), none} [owise] .


  op heatSuffix : -> TermList .
  eq heatSuffix = (mkVariable('Rest1,K),kApply(mkConstant(mkKLabel('heat),KLabel),empty),mkVariable('Rest2,K)) .

  op coolingEqs : Module Term Term Qid AttrSet -> EquationSet .
  eq coolingEqs(M, T1, T2, Q, AS)
   =  (ceq kWrap(Q, kra(mkVariable('Kcxt,NeK), freezeTerm(M, T1)))
         = kWrap(Q, T1[hole <- mkVariable('Kcxt,NeK)])
        if strictCondTerm(mkVariable('Kcxt,NeK),Q) = bool2K(trueCt)
       [metadata(AS pair("cooling",""))] .) 
      (ceq 'cool[kra(mkVariable('Kcxt,NeK), freezeTerm(M, T1),heatSuffix)]
        = 'cool[kra(T1[hole <- mkVariable('Kcxt,NeK)],heatSuffix)]
        if 'noFreezers_[mkVariable('Kcxt,NeK)] = trueCt
       [metadata(AS pair("supercool",""))] .)
     placeHolder(Q) .

  ops heatLabel redexLabel : -> Constant .
  eq heatLabel = mkConstant(mkKLabel('heat),KLabel) .
  eq redexLabel = mkConstant(mkKLabel('redex),KLabel) .

  op heatEqs : Qid Term Term Condition AttrSet AttrSet -> EquationSet .
  eq heatEqs(Q, T1, T2, Cnd, AS, AS')
   = $heatEqs(Q, T1, T2, Cnd, AS, AS')
     (ceq kWrap(Q, kApply(heatLabel, (mkVariable('AnyHeat1,KList), kApply(redexLabel,(kra(T1,mkVariable('RestHeat,K)),mkVariable('LHeat,KList))), mkVariable('AnyHeat2,KList))))
        = kWrap(Q, kApply(heatLabel, (mkVariable('AnyHeat1,KList), kApply(redexLabel,(kra(T1,mkVariable('RestHeat,K)),mkVariable('LHeat,KList),T2)), mkVariable('AnyHeat2,KList), kApply(redexLabel,kra(T2,mkVariable('RestHeat,K)))))) 
       if  Cnd /\ '_inList`{K`}_[T2, mkVariable('LHeat,KList)] = falseCt
     [metadata(AS pair("superheat", ""))] .) .

  op $heatEqs : Qid Term Term Condition AttrSet AttrSet -> EquationSet .
  eq $heatEqs(Q, T1, T2, Cnd, AS A, AS' nds(A AS''))
   = (ceq kWrap(Q, T1)
        = kWrap(Q, kApply(heatLabel,kApply(redexLabel,T1)))
       if Cnd 
      [metadata(AS A pair("superheat","start"))] .) .
  eq $heatEqs(Q, T1, T2, Cnd, AS, AS' nds(pair("default","") AS''))
   = (ceq kWrap(Q, T1)
        = kWrap(Q, kApply(heatLabel,kApply(redexLabel,T1)))
       if Cnd
      [metadata(AS pair("default","") pair("superheat","start"))] .) 
  [owise] .
  eq $heatEqs(Q, T1, T2, Cnd, AS, AS')
   = (ceq kWrap(Q, T1)
        = kWrap(Q, T2)
      if Cnd
      [metadata(AS pair("heating",""))] .) [owise] .

  op freezeTerm : Module Term -> Term .
  eq freezeTerm(M, T) = kApply(
   freezeLabel(untokenize(metaPrettyPrint(M,T, mixfix flat number rat))),
   freezeVariables(M, removeHole(noDuplicates(getVars(T))))) .

  op freezeVariables : Module TermList ~> TermList .
  op freezeVariable : Module Variable ~> Variable .
  eq freezeVariables(M, (V,Trl)) 
   = (freezeVariable(M, V),freezeVariables(M, Trl)) .
  eq freezeVariables(M, empty) = empty .

  eq freezeVariable(M, V) = freezeVariable(string(V),makeK(M,V, getType(V))) .

  op makeK : Module Variable Type ~> Term . 
  eq makeK(M, V, Type) = makeK(M, V, Type, sortLeq(M, Type, KList)) .

  op makeK : Module Variable Type Bool ~> Term . 
  eq makeK(M, V, Type, true) = V .
  eq makeK(M, V, Type, B:[Bool]) 
   = kApply(findWrapper(M, Type)[V],empty) .


  op strictCondTerm : Term Qid ~> Term .
  eq strictCondTerm(T, Q) = kApply(resultLabel(Q),T) .

  op strictCond : Term Qid ~> Term .
  eq strictCond(T, Q)
   = neqBool(strictCondTerm(T,Q),bool2K(trueCt)) .
  

  op strictCxt2eqs : Qid Qid Module Module SortSet AttrSet ~> Module .
  var Syntax StrictEqs : Qid . var M Flat : Module .

  eq strictCxt2eqs(Syntax,StrictEqs,M,Flat, Ss, AS) 
   = strictCxt2eqs(Syntax,StrictEqs,strictCxt2eqs(Flat, getMbs(M), AS), Ss) . --- [print "Syntax: " Syntax ", StrictEqs: " StrictEqs ", StrictCxt: " M] .

  op strictCxt2eqs : Qid Qid MASEqsPair SortSet ~> Module .
  eq strictCxt2eqs(Syntax, StrictEqs, {MAS,Eqs, Rls}, Ss) 
   = addOps(declareResultLabels(Eqs)--- coolOps
,setMbs(addRls(Rls, addEqs(defaultCoolEqs(Ss), 
        addEqs(generateResultEquations(Eqs), addImports((including Syntax . including 'K-STRICTNESS .), setName(emptySModule, StrictEqs))))), MAS)) .


  op placeHolder : Qid -> Equation .


  op declareResultLabels : EquationSet -> OpDeclSet .
  eq declareResultLabels(placeHolder(Q) Eqs) = (op getName(resultLabel(Q)) : nil -> KLabel [none] .) declareResultLabels(Eqs) .
  eq declareResultLabels(Eqs) = none [owise] .


  op generateResultEquations : EquationSet -> EquationSet .
  eq generateResultEquations(placeHolder(Q) Eqs)
   = generateResultEquations(Eqs) (eq kApply(resultLabel(Q), (mkVariable('K1,K),mkVariable('K2,K), mkVariable('L,KList))) = andBool(kApply(resultLabel(Q), (mkVariable('K1,K))), kApply(resultLabel(Q), (mkVariable('K2,K), mkVariable('L,KList)))) [none] .) (eq kApply(resultLabel(Q), nilKList) = bool2K(trueCt) [none] .) .
---(
   = generateResultEquations(Eqs) (eq kApply(resultLabel(Q),mkVariable('L,KList)) = bool2K(falseCt) [owise] .) .
---)
  eq generateResultEquations(Eqs) = Eqs [owise] .
endm

