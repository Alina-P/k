mod SYNTAX-PREDICATES is
  including META-MODULE-EXTRAS .
  including META-K-RULES .
  including META-LEVEL-EXTRAS .
  including PARSE-METADATA .
  including METADATA-EXTRAS .
  including META-K-MODULE .
  including K-META-OPS .
  including META-K-PREDICATES .
  including META-K-CONTEXTS .
  including META-ANONYMOUS-VARIABLE .
 
  op syntaxPreds : Module -> Module .
  eq syntaxPreds(M)
   = syntaxPreds(M, flatten(M)) .

  op syntaxPreds : Module Module -> Module .
  eq syntaxPreds(M, Flat)
   = syntaxPreds(M, Flat, removeSorts(lesserSorts(Flat, K), KItem ; K), makeSubsorts(Flat,getSorts(Flat),getSorts(Flat)), getOps(Flat)) .

  op syntaxPreds : Module Module SortSet  SubsortDeclSet OpDeclSet -> Module .
  eq syntaxPreds(M, Flat, SS, SSDS, OPDS) = syntaxPreds(M, Flat, SS \ builtinSorts(M,SS), builtinSorts(M, SS), SSDS, OPDS) .

  op syntaxPreds : Module Module SortSet SortSet SubsortDeclSet OpDeclSet -> Module .
  eq syntaxPreds(M, Flat, SS, BSS, SSDS, OPDS)
   = removeImports(removeSorts(removeSyntaxSubsorts(setMbs(setOps( 
                  setEqs(M,syntaxPredsEqs(SS, getEqs(M)))
                  ,
                  syntaxPreds(SS ; BSS) syntaxOps(M, Flat, SS ; BSS, getOps(M))
                  ),
            syntaxPredsMbs(SS, syntaxPreds(getSubsorts(SSDS, SS)) 
              syntaxPreds(getOps(OPDS, SS)) 
              getMbs(M))
              builtinSyntaxPreds(BSS)
            ), SS), SS), (including 'K-RESULT .)) .



  op removeSyntaxSubsorts : SubsortDeclSet SortSet -> SubsortDeclSet .
  eq removeSyntaxSubsorts(SSDS (subsort S < S' .), S ; SS)
   = removeSyntaxSubsorts(SSDS, S ; SS) .
  eq removeSyntaxSubsorts(SSDS (subsort S < S' .), S' ; SS)
   = if isBuiltin(S) then (subsort S < K .) removeSyntaxSubsorts(SSDS, S' ; SS) else removeSyntaxSubsorts(SSDS, S' ; SS) fi .
  eq removeSyntaxSubsorts(SSDS, SS) = SSDS [owise] .

  op removeSyntaxSubsorts : Module SortSet -> Module .
  eq removeSyntaxSubsorts(M, SS) 
   = setSubsorts(M, removeSyntaxSubsorts(getSubsorts(M),SS)) .



 op syntaxPredsMbs : SortSet MembAxSet ~> MembAxSet .
 eq syntaxPredsMbs(SS, Mbs Mb)
  =  syntaxPredsMbs(SS, Mbs) syntaxPredsMb(SS, noPredsDuplicates(syntaxVars(SS, getPredsVars(getTerm(Mb)))), Mb) .
 eq syntaxPredsMbs(SS, none) = none .

 op syntaxPredsMb : SortSet TermList MembAx ~> MembAx .
 eq syntaxPredsMb(SS, Trms, Mb)
  = $syntaxPredsMb(SS, Trms, mkKItems(getKItems(Trms), Mb)) .

 op $syntaxPredsMb : SortSet TermList MembAx ~> MembAx .
ceq $syntaxPredsMb(SS,Trms,Mb)
  = syntaxPredsKRl(SS, KRS, syntaxPredsT(SS, getContents(KRS)), syntaxCondition((Trms)))
 if KRS := splitKRule(Mb) [print "syntaxPredsMb splitKRule " KRS].
ceq $syntaxPredsMb(SS,Trms,Mb)
  = syntaxPredsKCxt(SS, KCS, syntaxPredsT(SS, getContents(KCS)), syntaxCondition((Trms))) 
 if KCS := splitKContext(Mb) .
ceq $syntaxPredsMb(SS,Trms,Mb)
  = plugKConfig(setContents(KCfgS,syntaxPredsT(SS, getContents(KCfgS))))
 if KCfgS := splitKConfig(Mb) .
---(
 eq syntaxPredsMb(SS,Mb)
  = plugMb(syntaxPredsT(SS,getTerm(Mb)), getType(Mb), getAttrs(Mb), mkBaseCondition(syntaxCondition(syntaxVars(SS, (getPredsVars(getTerm(Mb)))))) /\ syntaxPredsCond(SS, getCond(Mb))) [owise] .
---)

 op kitem : Variable -> Term .

 op getPredsVars : TermList -> TermList .
 eq getPredsVars(Trms) = $getPredsVars(Trms, 'dummy) .

 op $getPredsVars : TermList Qid -> TermList .
 eq $getPredsVars((Q[Trms],Trms'),Q')
  = if Q == replaceS then $getPredsVars((Trms, Trms'), Q') 
    else $getPredsVars(Trms,Q),$getPredsVars(Trms',Q') fi .
 eq $getPredsVars((V,Trms),Q) 
  = if Q == kraS then kitem(V) else V fi,$getPredsVars(Trms, Q) .
 eq $getPredsVars((Ct,Trms),Q) = $getPredsVars(Trms,Q) .
 eq $getPredsVars(empty,Q) = empty .

 op syntaxPredsKCxt : SortSet KContextSplit Term TermList ~> MembAx .
 eq syntaxPredsKCxt(SS, KCS, Trm, Trms) = plugKContext(setCondition(setContents(KCS, Trm), andBool(flattenSyntaxT(SS, getCondition(KCS),'dummy),Trms))) .

 op syntaxPredsKRl : SortSet KRuleSplit Term TermList ~> MembAx .
 eq syntaxPredsKRl(SS, KRS, Trm, Trms) = plugKRule(setCondition(setContents(KRS, Trm), andBool(flattenSyntaxT(SS, getCondition(KRS), 'dummy),Trms))) .


 op syntaxPredsT : SortSet Term ~> Term .
 eq syntaxPredsT(SS, Trm) = flattenSyntaxT(SS, Trm, 'dummy) .

  op flattenSyntaxT : SortSet TermList Qid ~> TermList .
  eq flattenSyntaxT(SS, (Q[Trms],Trms'), Q') 
   = Q[flattenSyntaxT(SS, Trms, if Q == replaceS then Q' else Q fi)],
     flattenSyntaxT(SS, Trms', Q') .
  eq flattenSyntaxT(SS, empty, Q) = empty .
  eq flattenSyntaxT(SS, (CV, Trms'), Q)  
   = if getType(CV) in SS 
     then setType(CV, if Q == kraS then KItem else K fi)
     else if getType(CV) == ResultList 
          then setType(CV, KList)
          else CV 
          fi
     fi, flattenSyntaxT(SS, Trms', Q) .

  op syntaxVars : SortSet TermList ~> TermList .
  eq syntaxVars(SS, empty) = empty .
  eq syntaxVars(SS, (V,Trms))
   = if isAnyAnyVar(V) == false and-then 
        (getType(V) in SS or-else getType(V) == ResultList)
     then V,syntaxVars(SS, Trms) else syntaxVars(SS, Trms) fi .
  eq syntaxVars(SS, (kitem(V), Trms))
   = kitem(syntaxVars(SS, V)),  syntaxVars(SS, Trms)  .
 
  eq kitem(empty) = empty .


  op isAnyAnyVar : Variable -> Bool .
  eq isAnyAnyVar(V)
   = substr(string(getName(V)),0,3 * length(string(anyVarS))) 
     == string(anyVarS) + string(anyVarS) + string(anyVarS) .

  op syntaxCondition_ : TermList ~> TermList .
  eq syntaxCondition(empty) = empty .
  eq syntaxCondition(NTrms) = andBool($syntaxCondition(NTrms)) .

  op $syntaxCondition_ : TermList ~> TermList .
  eq $syntaxCondition(empty) = empty .
  eq $syntaxCondition(V, Trms) 
   = if getType(V) == ResultList 
     then kApply(predicateLabel(KResult), setType(V,KList))
     else kApply(predicateLabel(getType(V)),setType(V,K)) 
     fi,syntaxCondition(Trms) .
  eq $syntaxCondition(kitem(V), Trms)
   = kApply(predicateLabel(getType(V)), setType(V,KItem)) .


 op syntaxPredsEqs : SortSet EquationSet ~> EquationSet .
 eq syntaxPredsEqs(SS, Eqs Eq)
  =  syntaxPredsEqs(SS, Eqs) syntaxPredsEq(SS, noPredsDuplicates(syntaxVars(SS, getPredsVars(getLhs(Eq)))), Eq) .
 eq syntaxPredsEqs(SS, none) = none .

 op syntaxPredsEq : SortSet TermList Equation ~> Equation .
 eq syntaxPredsEq(SS, Trms, Eq)
  = $syntaxPredsEq(SS, Trms, mkKItems(getKItems(Trms), Eq)) .

 op $syntaxPredsEq : SortSet TermList Equation ~> Equation .
 eq $syntaxPredsEq(SS, Trms, Eq)
  = plugEq(syntaxPredsT(SS, getLhs(Eq)), syntaxPredsT(SS, getRhs(Eq)), getAttrs(Eq), mkBaseCondition(syntaxCondition((Trms))) /\ syntaxPredsCond(SS, getCond(Eq))) .


 op mkBaseCondition : TermList ~> Condition .
 eq mkBaseCondition(empty) = nil .
 eq mkBaseCondition(Trm) = (Trm = trueCt) .
 

 op syntaxPredsCond : SortSet Condition ~> Condition .
 eq syntaxPredsCond(SS, Trm1 = Trm2 /\ Cond)
  = syntaxPredsT(SS, Trm1) = syntaxPredsT(SS, Trm2)
    /\ syntaxPredsCond(SS, Cond) .
 eq syntaxPredsCond(SS, Trm1 := Trm2 /\ Cond)
  = syntaxPredsT(SS, Trm1) := syntaxPredsT(SS, Trm2)
    /\ syntaxPredsCond(SS, Cond) .
 eq syntaxPredsCond(SS, Trm1 => Trm2 /\ Cond)
  = syntaxPredsT(SS, Trm1) => syntaxPredsT(SS, Trm2)
    /\ syntaxPredsCond(SS, Cond) .
 eq syntaxPredsCond(SS, Trm : Ty /\ Cond)
  = syntaxPredsT(SS, Trm) : Ty
    /\ syntaxPredsCond(SS, Cond) .
 eq syntaxPredsCond(SS, nil) = nil .


 op syntaxPreds : OpDeclSet ~> MembAxSet .
 eq syntaxPreds((op '<Floats> : nil -> Ty [AS] .) OPDS)
  = syntaxPreds(OPDS) .
 eq syntaxPreds((op Q : nil -> Ty [AS] .) OPDS)
   = plugKRule(R{replaceS[kApply(predicateLabel(Ty),mkConstant(Q,Ty)),trueCt],empty, removeOpAttrs(AS) metadata(pair("structural","") pair("predicate",""))}) 
     syntaxPreds(OPDS) [owise] .
 eq syntaxPreds((op Q : NeTyl -> Ty [AS] .) OPDS)
   = plugKRule(R{replaceS[kApply(predicateLabel(Ty),Q[genVars(Universal2K(NeTyl), "Is", 1)]),trueCt],empty, removeOpAttrs(AS) metadata(pair("predicate",""))}) 
     syntaxPreds(OPDS) .
 eq syntaxPreds((none).OpDeclSet) = none .


  op syntaxOps : Module Module SortSet OpDeclSet ~> OpDeclSet .
  eq syntaxOps(M, Flat, SS, Op OPDS)
   = syntaxOp(M, Flat, SS, Op)
     syntaxOps(M, Flat, SS, OPDS) .
  eq syntaxOps(M, Flat, SS, none) = none .

  
  op syntaxOp : Module Module SortSet OpDecl ~> OpDecl .
  eq syntaxOp(M, Flat, SS, (op Q : Tyl -> Ty [AS] .))
   = (op Q : syntaxTyl(M, Flat, SS, Tyl) -> syntaxRTy(M, Flat, SS, Ty) [AS ---(metadata(removeHybrid(metadataParse(AS))))] .) . 

  op syntaxTyl : Module Module SortSet TypeList ~> TypeList .
  eq syntaxTyl(M, Flat, SS, Ty Tyl) 
   = syntaxRTy(M, Flat, SS, Ty) 
     syntaxTyl(M, Flat, SS, Tyl)  .
  eq syntaxTyl(M, Flat, SS, nil) = nil .
     
  op syntaxTy : Module Module SortSet Type ~> Type .
  eq syntaxTy(M, Flat, SS, Ty) 
   = if Ty in SS then K else if Ty == ResultList then KList else Ty fi fi .

  op syntaxRTy : Module Module SortSet Type ~> Type .
  eq syntaxRTy(M, Flat, SS, Ty) 
   = if isBuiltin(Ty) then Ty else syntaxTy(M, Flat, SS, Ty) fi .

---(
  op removeHybrid : AttrSet -> AttrSet .
  eq removeHybrid(AS pair("hybrid","")) = AS .
  eq removeHybrid(AS) = AS [owise] .
---)

 op syntaxPreds : SubsortDeclSet ~> MembAxSet .
 eq syntaxPreds((subsort S < S' .) SSDS)
  = plugKRule(R{replaceS[kApply(predicateLabel(S'),mkVariable(S,S)),trueCt],empty, metadata(pair("predicate",""))}) 
    syntaxPreds(SSDS) .
 eq syntaxPreds((none).SubsortDeclSet) = none .

 op builtinSyntaxPreds : SortSet ~> MembAxSet .
 eq builtinSyntaxPreds(S ; SS) 
  = plugKRule(R{replaceS[kApply(predicateLabel(S),mkVariable(S,S)),trueCt],empty, metadata(pair("predicate",""))})  
    builtinSyntaxPreds(SS) .
 eq builtinSyntaxPreds(none) = none .

  op syntaxPreds : SortSet ~> OpDeclSet .
  eq syntaxPreds(S ; SS) 
   = (op predicateLabelS(S) : nil -> KLabel [metadata(pair("predicate", ""))] .) 
     syntaxPreds(SS) .
  eq syntaxPreds((none).SortSet) = none .
  
  --- eliminates term/variable duplicates (keeps only the leftmost occurrences
  op noPredsDuplicates : TermList -> TermList .
  eq noPredsDuplicates((Trms,Trm,Trms',Trm,Trms'')) = noPredsDuplicates((Trms,Trm,Trms',Trms'')) .
  eq noPredsDuplicates((Trms,kitem(Trm),Trms',Trm,Trms'')) = noPredsDuplicates((Trms,kitem(Trm),Trms',Trms'')) .
  eq noPredsDuplicates((Trms,Trm,Trms',kitem(Trm),Trms'')) = noPredsDuplicates((Trms,Trms',kitem(Trm),Trms'')) .
  eq noPredsDuplicates(Trms) = Trms [owise] .

  op getKItems_ : TermList ~> TermList .
  eq getKItems(empty) = empty .
  eq getKItems(V,Trms) = getKItems(Trms) .
  eq getKItems(kitem(V),Trms) = V,getKItems(Trms) .

  op mkKItems : TermList MembAx -> MembAx .
  eq mkKItems(empty, Mb) = Mb .
  eq mkKItems((V, Trms), Mb) = mkKItems(Trms, Mb[V <- setType(V,KItem)]) .

  op mkKItems : TermList Equation -> Equation .
  eq mkKItems(empty, Eq) = Eq .
  eq mkKItems((V, Trms), Eq) = mkKItems(Trms, Eq[V <- setType(V,KItem)]) .

  var Q Q' : Qid .  var Ct : Constant .
  var Ty : Type . var NeTyl : NeTypeList .  var Tyl : TypeList .

  var OPDS : OpDeclSet . var Op : OpDecl .  var AS : AttrSet .
  var SSDS : SubsortDeclSet .  var SS BSS : SortSet . var S S' : Sort .
  var M Flat : Module .
  var Mbs : MembAxSet .  var Mb : MembAx . 
  var Eqs : EquationSet .  var Eq : Equation . 
  var Trm Trm1 Trm2 : Term .   var CV : Term . var V : Variable .
  var Trms Trms' Trms'' : TermList .  var NTrms : NeTermList .  var Cond : Condition .
  var KRS : KRuleSplit . var KCS : KContextSplit .  var KCfgS : KConfigSplit .
endm
