fmod MAKE-K-RULES is
  including META-MODULE-EXTRAS .
  including  META-K-RULES .
  including  META-K-CONTEXTS .
  including META-K-COOL .
  including META-LEVEL-EXTRAS .
  including META-K-CONDITION-SEARCH .
  including PARSE-METADATA .
  including COMPILATION-ATTRS .
  var M Flat : Module .  var T T1 T2 Trm T3 T4 : Term .  var Cond : TermList .
  var Cnd : Condition .
  var Cxt : String .
  var AS AS' AS'' : AttrSet .  var A : Attr .
  var C : Term . var S : Sort .  var Ss : SortSet . var Subst : Substitution .
  var Ct : Constant . var V : Variable .
  var O O' Q : Qid . var N : Nat . var Tl Tl'  : TermList .
  var KRuleType : KRuleKind .  var Split : KRuleSplit .
  var Mas : MembAxSet . var Max : MembAx .
  var Str : String .
  var OPDS : OpDeclSet . var Op : OpDecl .  var Ty : Type .
  var Rl : Rule . var Rls : RuleSet . var Eq : Equation . var Eqs : EquationSet .
  
  op resolveKRules : Qid Module Module SortSet AttrSet -> Module .
  eq resolveKRules(O, M, Flat, Ss, AS) = setCoolName(resolveReplace(setOps(setEqs(setRls(Flat,none),none),clearReductionAttrs(getOps(Flat)) coolCellOps(Ss)), addOps(coolCellOps(Ss),setMbs(addImports( including 'K-STRICTNESS ., removeImports(M, (including 'K-RULES .) (including 'K-CONDITION-SEARCH .))),none)), getMbs(M), coolSubst(Ss), AS), O) .
  
  op coolCellOps : SortSet -> OpDeclSet .
  eq coolCellOps(none) = none .
  eq coolCellOps(S ; Ss) 
   = (op cool(S) : nil -> CellLabel [none] .)
     coolCellOps(Ss) .

  op coolSubst : SortSet -> Substitution .
  eq coolSubst(none) = none .
  eq coolSubst(S ; Ss)
   = (mkCellLabel(S) <- mkCellLabel(cool(S))) ;
     coolSubst(Ss) .

  op resolveReplace : Module Module MembAxSet Substitution AttrSet -> Module .
  eq resolveReplace(Flat, M, none, Subst, AS) = removeReplaceOps(M) .
  eq resolveReplace(Flat, M, Max Mas, Subst, AS)
   = resolveReplace(Flat, M, metadataParse(Max), Mas, Subst, AS) .
  op resolveReplace : Module Module MembAx MembAxSet Substitution AttrSet -> Module .
 ceq resolveReplace(Flat, M, Max, Mas, Subst, AS)
   = resolveReplace(Flat, addReplace(Flat, M, Split, Subst, AS), Mas, Subst, AS)
  if Split := splitKRule(Max) [print "Split:" Split].
 ceq resolveReplace(Flat, M, Max, Mas, Subst, AS)
   = resolveReplace(Flat, addCxtReplace(Flat, M, CSplit), Mas, Subst, AS)
  if CSplit := splitKContext(Max) .
  eq resolveReplace(Flat, M, Max, Mas, Subst, AS) 
   = resolveReplace(Flat, addMbs(Max, M), Mas, Subst, AS) [owise] .
  eq resolveReplace(Flat,  errorM(AS:AttrSet, Str:String, T:[Term], Cxt:String, U:Module), Mas, Subst, AS')
   = errorM(AS:AttrSet, Str:String, T:[Term], Cxt:String, Flat) .
  eq resolveReplace(Flat, M, errorMb(Trm,Cxt,Str,AS), Mas, Subst, AS')  = errorM(AS, Str, Trm, Cxt, Flat)  [print "errorMb propagated to module"] .

  op removeReplaceOps : Module -> Module .
  eq removeReplaceOps(M) = setOps(M, removeReplaceOps(getOps(M))) .
  
  op removeReplaceOps : OpDeclSet -> OpDeclSet .
  eq removeReplaceOps((op Q : Ty Ty -> Ty [AS] .) OPDS) 
   = if Q == replaceS then removeReplaceOps(OPDS) else (op Q : Ty Ty -> Ty [AS] .) removeReplaceOps(OPDS) fi .
 ceq removeReplaceOps((op Q : Ty 'K -> '`[KSentence`] [AS] .) OPDS)
   = removeReplaceOps(OPDS) if Q = symbol kcrl .
 ceq removeReplaceOps((op Q : Ty -> '`[KSentence`] [AS] .) OPDS)
   = removeReplaceOps(OPDS) if Q = symbol krl .
  eq removeReplaceOps(Op OPDS) = Op removeReplaceOps(OPDS) [owise] .
  eq removeReplaceOps(none) = none .


---------  Hack to get rid of the potential attribute large
  eq klarge = none . 
---------

  op addCxtReplace : Module Module KContextSplit ~> Module .
  eq addCxtReplace(Flat, M, CSplit) = addMbs(plugKContext(setAttrs(setContents(CSplit, replaceCxt(splitReplace(Flat, getContents(CSplit),1), getHoleReplacement(getContents(CSplit)))),metadata(getAttrs(CSplit)))), M) .

  op addReplace : Module Module KRuleSplit Substitution AttrSet ~> Module .
  eq addReplace(Flat, M, R{T,Cond,AS}, Subst, AS')
   = $$addReplace(M, addK(Flat, AS, AS', normalize(Flat,splitReplace(Flat, T,1))), addK(Flat, AS, AS', normalize(Flat,splitReplace(Flat, T,2))), makeCondition(Cond), Subst, AS, AS') .

  op $$addReplace : Module Term Term Condition Substitution AttrSet AttrSet ~> Module .
  eq $$addReplace(M, T1, T2, Cnd, Subst, AS, AS')
   = $$$addReplace(M, T1, handleTagSuperCooling(T2, Subst, AS, AS'), heatedK(T1), T2, Cnd, Subst, AS, AS') .

  op $$$addReplace : Module Term Term Term Term Condition Substitution AttrSet AttrSet ~> Module .
  eq $$$addReplace(M, T1, T2, T1, T4, Cnd, Subst, AS, AS')
   = $addReplace(M, T1, T2, T1, T4, Cnd, AS, AS') .
  eq $$$addReplace(M, T1, T2, T3, T4, Cnd, Subst, AS, AS')
   = $addReplace(M, T1, T2, T3, heatedTailK(T4)[Subst], Cnd, AS, AS') [owise] .

  op $addReplace : Module Term Term Term Term Condition AttrSet AttrSet ~> Module .

  eq $addReplace(M, T1, T2, T3, T4, Cnd, AS pair("predicate",Str), AS')
   = addStructural(M, T1, T2, T3, T4, Cnd, AS pair("predicate",Str), AS')  .
  eq $addReplace(M, T1, T2, T3, T4, Cnd, AS pair("function",Str), AS')
   = addStructural(M, T1, T2, T3, T4, Cnd, AS pair("function",Str), AS') .
  eq $addReplace(M, T1, T2, T3, T4, Cnd, AS A, transitions(A AS'') AS')
   = addTransition(M, T1, T2, T3, T4, Cnd, AS A, AS') .
  eq $addReplace(M, T1, T2, T3, T4, Cnd, AS pair(Str,Str':String), transitions(pair(Str, Str'':String) AS'') AS')
   = addTransition(M, T1, T2, T3, T4, Cnd, AS pair(Str, Str':String), AS') .
  eq $addReplace(M, T1, T2, T3, T4, Cnd, AS, transitions(pair("default","") AS'') AS')
   = addTransition(M, T1, T2, T3, T4, Cnd, AS pair("default",""), AS') .
  eq $addReplace(M, T1, T2, T3, T4, Cnd, AS, AS')
   = addStructural(M, T1, T2, T3, T4, Cnd, AS pair("default",""), AS') [owise] .
  eq $addReplace(M, errorT(Err:[Term],Cxt:String,Msg:String), T2:[Term], T3:[Term], T4:[Term], Cnd:[Condition], AS, AS')
   = errorM(AS,Msg:String,Err:[Term],Cxt:String,M) .
  eq $addReplace(M, T2:[Term], errorT(Err:[Term],Cxt:String,Msg:String), T3:[Term], T4:[Term], Cnd:[Condition], AS, AS')
   = errorM(AS,Msg:String,Err:[Term],Cxt:String,M) .
  
  op addStructural : Module Term Term Term Term Condition AttrSet AttrSet ~> Module .  
  eq addStructural(M, T1, T2, T3, T4, Cnd, AS, AS')
   = superCoolName(addEqs(plugEq(T1,T2,metadata(AS),Cnd) if T3 =/= T1 then plugEq(T3, T4, metadata(AS pair("superheated","")), Cnd) else none fi, M), AS, AS') .

  op addTransition : Module Term Term Term Term Condition AttrSet AttrSet ~> Module .  
  eq addTransition(M, T1, T2, T3, T4, Cnd, AS, AS')
   = superCoolName(addRls(plugRl(T1,T2,metadata(AS),Cnd) if T3 =/= T1 then plugRl(T3, T4, metadata(AS pair("superheated","")), Cnd) else none fi, M), AS, AS') .

  op handleTagSuperCooling : Term Substitution AttrSet AttrSet -> Term .
  eq handleTagSuperCooling(T, Subst, A AS, AS' supercools(A AS'')) = T[Subst] .
  eq handleTagSuperCooling(T, Subst, pair(Str,Str':String) AS, AS' supercools(pair(Str,Str'':String) AS'')) = T[Subst] .
  eq handleTagSuperCooling(T, Subst, AS, AS' supercools(pair("default","") AS'')) = T[Subst] .
  eq handleTagSuperCooling(T, Subst, AS, AS') = T [owise] .
  eq handleTagSuperCooling(errorT(Err:[Term],Cxt:String,Msg:String), Subst, AS, AS') =  errorT(Err:[Term],Cxt:String,Msg:String) .

  op makeCondition : TermList -> Condition .
  eq makeCondition(empty) = nil .
 ceq makeCondition(O'[O[T1,T2]])
   = T1 => T2 
  if O' = searchS /\ O = replaceS .
  eq makeCondition(T) = makeKCondition(T) [owise] .


  op superCoolName : Module AttrSet AttrSet -> Module .
  eq superCoolName(M, pair(Str,Str':String) AS, AS' supercools(pair(Str,Str'':String) AS'')) = setName(M, '#SUPERCOOL) .
  eq superCoolName(M, A AS, AS' supercools(A AS'')) = setName(M, '#SUPERCOOL) .
  eq superCoolName(M, AS, AS' supercools(pair("default","") AS'')) = setName(M, '#SUPERCOOL) .
  eq superCoolName(M, AS, AS') = M [owise] .
  eq superCoolName(errorM(Atts:AttrSet,Msg:String,Err:[Term],Cxt:String,ErrMod:Module), AS, AS') = errorM(Atts:AttrSet,Msg:String,Err:[Term],Cxt:String,ErrMod:Module) .

  op setCoolName : Module Qid -> Module .
  eq setCoolName(M, Q) = setCoolName(M, Q, getName(M)) .
  eq setCoolName(errorM(Atts:AttrSet,Msg:String,Err:[Term],Cxt:String,ErrMod:Module), Q) = errorM(Atts:AttrSet,Msg:String,Err:[Term],Cxt:String,ErrMod:Module) .
  
  op setCoolName : Module Qid Qid -> Module .
  eq setCoolName(M, Q, '#SUPERCOOL) = setName(M, qid("#SUPERCOOL-" + string(Q))) .
  eq setCoolName(M, Q, O) = setName(pruneHeated(M), Q) [owise] .


  op addK : Module AttrSet AttrSet Term -> Term .
  eq addK(Flat, A AS, anywheres(A AS') AS'', T) = T .
  eq addK(Flat, pair(Str,Str':String) AS, anywheres(pair(Str,Str'':String) AS') AS'', T) = T .
  eq addK(Flat, AS, AS', T) = if getKind(Flat, leastSort(Flat, T)) == getKind(Flat, K) then kWrap(T) else T fi [owise print "Attributes: "
AS "\n\t" AS'] .
  eq addK(Flat, AS, AS', errorT(Err:[Term],Cxt:String,Msg:String)) = errorT(Err:[Term],Cxt:String,Msg:String) .


  op heatedK_ : TermList -> TermList .
 ceq heatedK(T, Tl) =  heatedK(SC), heatedK(Tl)
  if SC := splitKCell(T) /\ getName(SC) == klabel .
  eq heatedK(Q[Tl], Tl') = Q[heatedK(Tl)], heatedK(Tl') [owise] .
  eq heatedK(V, Tl) = V, heatedK(Tl) .
  eq heatedK(Ct, Tl) = Ct, heatedK(Tl) .
  eq heatedK(empty) = empty .

  op heatedK : SplitCell -> Term .
  eq heatedK(SC) = plugCell(setContents(SC, heatedTerm(getContents(SC)))) .


  op heatedTerm : Term -> Term .
  eq heatedTerm(T) = kra(kApply(heatLabel,(kApply(heatedLabel,(mkVariable('KsHeated,KList), T, mkVariable('KsHeated',KList))))),mkVariable('KHeated,K)) .


 op heatedTailK_ : TermList -> TermList .
 ceq heatedTailK(T, Tl) =  heatedTailK(SC), heatedTailK(Tl)
  if SC := splitKCell(T) /\ getName(SC) == klabel .
  eq heatedTailK(Q[Tl], Tl') = Q[heatedTailK(Tl)], heatedTailK(Tl') [owise] .
  eq heatedTailK(V, Tl) = V, heatedTailK(Tl) .
  eq heatedTailK(Ct, Tl) = Ct, heatedTailK(Tl) .
  eq heatedTailK(empty) = empty .

  op heatedTailK : SplitCell -> Term .
  eq heatedTailK(SC) = plugCell(setContents(SC, heatedTailTerm(getContents(SC)))) .


  op heatedTailTerm : Term -> Term .
  eq heatedTailTerm(T) = kra(T,mkVariable('KHeated,K)) .


  op pruneHeated : Module ~> Module .
  eq pruneHeated(M) = setEqs(setRls(M, pruneHeatedRls(getRls(M))), pruneHeatedEqs(getEqs(M))) .
  
  op pruneHeatedRls : RuleSet ~> RuleSet .
  eq pruneHeatedRls(Rl Rls) = if heated(metadataParse(getAttrs(Rl))) then pruneHeatedRls(Rls) else Rl pruneHeatedRls(Rls)  fi .
  eq pruneHeatedRls(none) = none .

  op pruneHeatedEqs : EquationSet ~> EquationSet .
  eq pruneHeatedEqs(Eq Eqs) = if heated(metadataParse(getAttrs(Eq))) then pruneHeatedEqs(Eqs) else Eq pruneHeatedEqs(Eqs)  fi .
  eq pruneHeatedEqs(none) = none .


  op heated : AttrSet -> Bool .
  eq heated(pair("superheated",Str:String) AS) = true .
  eq heated(AS) = false [owise] .


  var CSplit : KContextSplit .
  var SC : SplitCell .
endfm

