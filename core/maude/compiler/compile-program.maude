fmod COMPILE-PROGRAM is
  including META-TERM-EXTRAS .
  including META-LEVEL-EXTRAS .
  including META-K-LABELS .
  including K-META-OPS .
  including K-META-LISTS .
---  including SANITY-CHECKS .

  vars Syntax : Module .
  var SyntaxOps Ops : OpDeclSet .  var AS : AttrSet .
  var Eqs : EquationSet .
  vars Trms Trms' : TermList .  var Trm : Term .
  var Q : Qid .  var W : [Qid] .
  var C : Constant .
  var Tl : TypeList . var T T' T'' : Type .

  op errorTrm : Term Type -> [Term] .
  
  op compileProgram2Term : Module Qid ~> Term .
  eq compileProgram2Term(Syntax, Q)
   = compileProgram(Syntax, getOps(Syntax), Q) .

  var Trm' : Term .
  op compileProgram : Module OpDeclSet Qid ~> Term .
  eq compileProgram(Syntax, SyntaxOps op Q : nil -> T [AS] ., Q)
   =  compileProgram(Syntax, SyntaxOps, getEqs(Syntax), mkConstant(Q, T)) .
  eq compileProgram(Syntax, SyntaxOps, Q) = errorTrm(upTerm("Could not find program " + string(Q)),'Error) [owise] .

  op compileProgram : Module OpDeclSet EquationSet Constant ~> Term .
  eq compileProgram(Syntax, SyntaxOps, Eqs eq C = Trm [AS] ., C)
   = compileProgram(Syntax, SyntaxOps, leastSort(Syntax,Trm), Trm, true ---sanityCheckT(Trm, Syntax)
   ) [print "compiling " Trm].
  
  op compileProgram : Module OpDeclSet Type Term Bool ~> Term .
  eq compileProgram(Syntax, SyntaxOps, T, Trm, true)
   = if isListSort(Syntax,T) then compileProgram(Syntax, SyntaxOps, getListConstructor(SyntaxOps, T), Trm)
     else compileProgram(Syntax, SyntaxOps, T,  compileProgramGetWrapper(leastSort(Syntax, Trm)), Trm) fi .
---  eq compileProgram(Syntax, SyntaxOps, T, Trm, error(Trm, T'))
---   = errorTrm(Trm, T') .


  op compileProgramGetWrapper : Type ~> Qid .
 ceq compileProgramGetWrapper(T'')
   = '#_  
  if isBuiltin(T'') [print "Testing wrapper for " T''].
---  /\ sortLeq(Compiled,T'', T) .

  op compileProgram : Module OpDeclSet OpDecl Term ~> Term .
  eq compileProgram(Syntax, SyntaxOps, op Q : Tl -> T [AS id(C)] ., Trm)
   = kApply(mkConstant(mkKLabel(Q),KLabel), compileProgramL(Syntax, SyntaxOps, Q, C, Trm)) [print "Compile " Trm " with list ctor " Q " and id " C] .

  op compileProgramL : Module OpDeclSet Qid Constant TermList ~> TermList .
  eq compileProgramL(Syntax, SyntaxOps, Q, C, (Trms',Q[Trms])) = compileProgramL(Syntax, SyntaxOps, Q, C, (Trms', Trms)) .
  eq compileProgramL(Syntax, SyntaxOps, Q, C, (Trms',C)) 
   = compileProgramL(Syntax, SyntaxOps, Q, C, Trms') .
  eq compileProgramL(Syntax, SyntaxOps, Q, C, (Trms',Trm)) 
   = compileProgramL(Syntax, SyntaxOps, Q, C, Trms'), compileProgram(Syntax, SyntaxOps, leastSort(Syntax, Trm), compileProgramGetWrapper(leastSort(Syntax, Trm)), Trm) .
  eq compileProgramL(Syntax, SyntaxOps, Q, C, empty) 
   = empty .

  op compileProgram : Module OpDeclSet Type Qid Term ~> Term .
  eq compileProgram(Syntax, SyntaxOps, T, W, Trm) 
   = if W :: Qid then kApply(W[Trm],  empty) 
     else compileProgramT(Syntax, SyntaxOps, leastSort(Syntax, Trm), Trm) fi 
    [print "Compiling term " Trm " with type " T " and Wrapper " W] .
  
  op compileProgramT : Module OpDeclSet Type Term ~> Term .
  eq compileProgramT(Syntax, SyntaxOps, T, Q[Trms])
   = compileProgramT(Syntax, SyntaxOps, findOp(Syntax, SyntaxOps,Q, leastSorts(Syntax, Trms), T), Trms) .
  eq compileProgramT(Syntax, SyntaxOps, T, C)
   = kApply(mkConstant(mkKLabel(getName(C)),KLabel), empty) .

  op compileProgramT : Module OpDeclSet OpDecl TermList ~> Term .
  eq compileProgramT(Syntax, SyntaxOps, op Q : Tl -> T [AS] ., Trms) = kApply(mkConstant(mkKLabel(Q),KLabel), compileProgramTs(Syntax, SyntaxOps, Tl, Trms)) .

  op compileProgramTs : Module OpDeclSet TypeList TermList 
                      ~> TermList .
  eq compileProgramTs(Syntax, SyntaxOps, Tl T, (Trms, Trm))
   = compileProgramTs(Syntax, SyntaxOps, Tl, Trms),
     compileProgram(Syntax, SyntaxOps, T, Trm, true) .
  eq compileProgramTs(Syntax, SyntaxOps, nil, empty) 
   = empty .
endfm
