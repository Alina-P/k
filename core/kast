#!/usr/bin/env perl

# imports
use strict;
use warnings;
use Getopt::Long;
use File::Spec;
use File::Basename;
use Time::HiRes qw( gettimeofday tv_interval);
# specific imports : common_functions.pl
my $namespace = File::Spec->catfile((File::Basename::fileparse($0))[1], 'common_functions.pl');
require $namespace;

my $tstart = [gettimeofday];
my $t0 = [gettimeofday];
my $elapsed = 0;

################
# Variables    #
################

# options
my $help;

my $pgm           = "?";
my $pmod          = "?";
my $lang         = "?";
my $sort_         = "?";
my $syntax_module = "?";
my $verbose       = 0;


# utils
my @all_tokens  = ();
my @all_syntax  = ();
my @identifiers = ();
my $k_tools_dir = File::Spec->catfile((File::Basename::fileparse($0))[1], 'maude','compiler');
my $k_prelude = File::Spec->catfile($k_tools_dir,"..","lib","k-prelude");

# compile program 
my $begin_compiled_module = "---K-MAUDE-GENERATED-OUTPUT-BEGIN---";                                                               
my $end_compiled_module   = "---K-MAUDE-GENERATED-OUTPUT-END---";   

# comments
my $comment = join("|", (                                                                                                      
    "\\/\\/.*?\n",                                                                                                       
    "\\/\\*.*?\\*\\/",                                                                                                   
    "---\\(.*?---\\)",                                                                                          
    "---.*?\n",                                                                                                  
    "\\*\\*\\*\\(.*?\\*\\*\\*\\)",                                                                              
    "\\*\\*\\*.*?\n" )); 



################
# main         #
################

# read command line arguments
usage() if (@ARGV < 1 or
    ! GetOptions('help|?' => \$help,
	'pgm=s'     => \$pgm,
	'pmod=s'    => \$pmod,
	'lang=s'   => \$lang,
	'sort=s'    => \$sort_,
	'smod=s'    => \$syntax_module,
	'v|verbose' => \$verbose,
    ) or defined $help );


# check if command line options are set.
# arg_error("Please set all command options; -pgm is not given!") if $pgm eq "?";
# arg_error("Please set all command options; -pmod is not given!") if $pmod eq "?";
# arg_error("Please set all command options; -cfile is not given!") if $lang eq "?";
arg_error("Please set all needed command options; -sort is not given!") if $sort_ eq "?";
# arg_error("Please set all needed command options; -smod is not given!") if $syntax_module eq "?";


##############################
# solve command line options #
##############################
if ($pgm eq "?")
{
    if (-e $ARGV[0])
    {
	$pgm  = $ARGV[0];
    }
    else
    {
	print "If option -pgm is not used then kast program considers the FIRST argument as being the program file. If this file is not found, it returns this error.\n";
	exit(1);
    }
}

my ($fname, $path, $suffix) = fileparse($pgm, qr/\.[^.]*/);
if ($suffix eq "")
{
    print "Cannot infer lang name. Please make sure that $fname has the form \"program_name.lang\" (e.g. helloworld.c).\n \"lang\" (e.g \"c\") is the name of your language; both \"lang.k\" and \"lang-compiled.maude\" must exist.\n";
    exit(1);
}

# 1. program module
$pmod = uc($fname) if ($pmod eq "?");
# 2. compiled file
$suffix =~ s/^\.//;
$lang = $suffix if ($lang eq "?");
# 3. syntax module
$syntax_module = uc($lang) . "-SYNTAX" if ($syntax_module eq "?");


# message
print "Maudifying program ... " if $verbose;


##############################################################
# collect identifiers from program:                          #
# 1. eliminate comments                                      #
# 2. eliminate strings                                       #
# 3. eliminate tokens + keywords from program                #
# 4. collect all left possible identifiers and declare them  #
##############################################################


# get the program
local $_ = get_file_content($pgm);
my $temp = $_;

# get tokens
my $dir = dirname($lang);
my $tokens_file = File::Spec->catfile($dir, ".k/all_tokens.tok");
my $tokens = get_file_content($tokens_file);
my @all = split("\n", $tokens);
@all_tokens = split('\s', shift(@all));
@all_syntax = split('\s', shift(@all));


# remove comments
s!($comment)!
{
    local $_ = $1;
    s/\S//gs;
    $_;
}!gse;


# remove strings
s/(?<!\\)".*?(?<!\\)"//sg;

# syntax contains undescores:
# remove them and keep only keywords
my @temp = ();
for my $syntax_item (@all_syntax)
{
    my @keywords = split("[^a-zA-Z]+", $syntax_item);
    for my $kwd (@keywords)
    {
	push(@temp, $kwd);
    }
    
    push(@temp, $syntax_item) if !(scalar @keywords > 0);
}

@all_tokens = reverse length_sort(@all_tokens);
@all_syntax = reverse length_sort(@temp);

# print "TOKENS: @all_tokens\n\n@all_syntax\n\nPROGRAM:$_\n\n";

# remove syntax
for my $syntax_item (@all_syntax)
{
    # remove bounded alpha-characters
    if ($syntax_item =~ /\b[a-zA-Z_]+\b/s)
    {
	s/\b($syntax_item)\b/ /sg;
    }
}

# remove the rest of tokens (in reversed topological order)
# make sure this is still needed ...
for my $token (@all_tokens)
{
    s/\Q$token\E/ /sg;
}


# collect identifiers
s/\b([a-zA-Z_\$][a-zA-Z_0-9]*)(?=(\s|$))/
{
    push (@identifiers, $1);
    "";
}/sge;

# make identifiers unique
@identifiers = set(@identifiers);


############################
# end section              #
############################







##############################
# Creating the Maude module  #
# 1. tokenize the program    #
# 2. create a maude module   #
##############################

####################
# 1. tokenization  #
####################
$_ = $temp;

# remove extension of program file
$pgm =~ s/\..*$//s;
my $ids = join(" ", @identifiers);


# remove comments
s!($comment)!
{
    local $_ = $1;
    s/\S//gs;
    $_;
}!gse;


# replace found ids with id("...");
# also use freeze/unfreeze for strings
my @ordered_ids = reverse length_sort(@identifiers);
s/(?<!\\)".*?(?<!\\)"/Freeze($&, "STRINGS")/sge;
for my $id (@ordered_ids)
{
    s/(?<![a-zA-Z_0-9])($id)(?![a-zA-Z_0-9])/id("$1")/sg;
}

# freeze also the construct id("identifier")
s/id\((?<!\\)".*?(?<!\\)"\)/Freeze($&, "STRINGS")/sge;

# spacify
my @tks = (@all_tokens, @all_syntax);
$_ = spacify($_, @tks);

# unfreeze everything
$_ = Unfreeze("STRINGS", $_);
#  print "PROGRAM:\n$_\n\n";


##########################
# 2. Create maude module #
##########################

# transform program in equation
$_ = "eq $pgm = ( $_ ) .";

# add sort declaration
s/^/ops $pgm : -> $sort_ .\n/;

# add identifier declarations
s/^/ops $ids : -> #Id .\n/ if $ids ne "";

# add mod
s/^/mod $pmod is including $syntax_module .\n/;

# add endm
s/$/\nendm/;

# add imports
s/^/load .k\/$lang.maude\n/;


#################################
# compile the file              #
#################################

my $pname = $pgm;
my $cfile = "$lang-compiled.maude";
my $cmod = uc($lang);

if (!(-e $cfile))
{
    print "Cannot find the compiled definition ($cfile).\nCompile your definition first.\n";
    exit(1);
}

my $maudified = $_;
my $compiled =  qx{ sed 2d $cfile};

my $compile =
  "set include PL-BOOL off .
  set include BOOL on .
  load \"$k_tools_dir/" . "prelude-extras\"
  load \"$k_tools_dir/" . "meta-k\"
  
  load  \"$k_tools_dir/" . "compile-program-interface\"
  ---(
      set print attribute on .
      red in COMPILE-PROGRAM-META : compileProgram(\"$pmod\",\"$pname\") .
      q
  ---)
  loop compile-program .
  (compileProgram $pmod $pname .)
  q
  ";

my $tempFile = "programCompile.tmp";
open MYFILE,">",$tempFile or die "Cannot create $tempFile\n";
print MYFILE "load \"$k_prelude\"\n$maudified\n$compile\n";
close(MYFILE);
# push(@generated_files, $tempFile);


$elapsed = tv_interval ( $t0 );
print "DONE [" . sprintf("%.3f", $elapsed) . "s]\n" if $verbose;
$t0 = [gettimeofday];
print "Compiling program .... " if $verbose;


# run maude with this input
my $output = `maude -no-wrap programCompile.tmp`;



$elapsed = tv_interval ( $t0 );
print "DONE [" . sprintf("%.3f", $elapsed) . "s]\n" if $verbose;
$t0 = [gettimeofday];



if ($output =~ /$begin_compiled_module(.*?)$end_compiled_module/sg)
{
    # save
    my $term = $1;
    $term =~ s/^\s//sg;
    my $name = $pgm;
    open FILE, ">", "$fname.kast" or die "Cannot create $fname.kast\n";
    print FILE $term;
    close FILE;
}
else 
{
    print "Maude (compileProgram) returned no output ...\n";
}

unlink("programCompile.tmp") if !$verbose;

$elapsed = tv_interval ( $tstart );
print "Total time ........... DONE [" . sprintf("%.3f", $elapsed) . "s]\n\n" if $verbose;

# print "$output\n\n\n";



################
# end main     #
################





###########
# utils   #
###########

# an attempt to tokenize a program
sub spacify
{
    local $_ = shift;
    my @tokens = @_;
    
    my @temp = @tokens;
    @tokens = ();
    for my $tok (@temp)
    {
	my @keywords = split("_", $tok);
	for my $kwd (@keywords)
	{
	    push(@tokens, $kwd) if $kwd ne "";
	}
    }

    @tokens = reverse length_sort(set(@tokens));
    
    my @tkz = ();
    for my $tok (@tokens)
    {
	if ($tok ne ";")
	{
	    push(@tkz, quotemeta($tok));
	}
	else
	{
	    push(@tkz, $tok);
	}
    }
    
    my $tokens_pattern = join("|", @tkz);

    s/($tokens_pattern)/ $1 /sg;

    $_;
}



# print a help message and exit
sub usage
{
    print "Unknown option: @_\n" if @_;
    print "usage: cast [-pgm] program_name [-pmod program_module] [-cfile compiled_file] -sort pgm_sort -smod syntax_module\n\t[-verbose]\n\n
  Options:
  \t-verbose: verbose mode
  \t-pgm    : specify the file where the program is.
  \t-pmod   : specify the name of the module which will wrap the program
  \t-lang   : specify a k compiled file
  \t-sort   : specify program sort
  \t-smod   : specify the syntax module name\n\n";

    exit;
}

# print an error message if arguments not set
sub arg_error
{
    print shift(@_) . "\n";
    usage();
}

# returns file content as string
sub get_file_content
{
    my $filename = shift;
    
    open FILEHANDLE, "<", $filename or die "Could not open $filename:\n$!";
    my @input = <FILEHANDLE>;
    close FILEHANDLE;

    return join("", @input);
}

# sorts an array by length of its elements
sub length_sort
{
    sort {length $a <=> length $b} @_;
}

# get set-like array from another array
# get rid of duplicates
sub set
{
    if (@_)
    {
	my %map = map { $_ => 1 } @_;
	return keys %map;
    }
    
    ();
}
