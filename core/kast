#!/usr/bin/env perl

# imports
use strict;
use warnings;
use Getopt::Long;
use File::Spec;
use File::Basename;
use Time::HiRes qw( gettimeofday tv_interval);
# specific imports : common_functions.pl
my $namespace = File::Spec->catfile((File::Basename::fileparse($0))[1], 'common_functions.pl');
require $namespace;

my $tstart = [gettimeofday];
my $t0 = [gettimeofday];
my $elapsed = 0;

################
# Variables    #
################

# options
my $help;

my $pgm           = "?";
my $pmod          = "?";
my $lang         = "?";
my $sort_         = "?";
my $syntax_module = "?";
my $verbose       = 0;


# utils
my @all_tokens  = ();
my @all_syntax  = ();
my @identifiers = ();
my $k_tools_dir = File::Spec->catfile((File::Basename::fileparse($0))[1], 'maude','compiler');
my $k_prelude = File::Spec->catfile($k_tools_dir,"..","lib","k-prelude");

# compile program 
my $begin_compiled_module = "---K-MAUDE-GENERATED-OUTPUT-BEGIN---";                                                               
my $end_compiled_module   = "---K-MAUDE-GENERATED-OUTPUT-END---";   

# comments
my $comment = join("|", (                                                                                                      
    "\\/\\/.*?\n",                                                                                                       
    "\\/\\*.*?\\*\\/",                                                                                                   
    "---\\(.*?---\\)",                                                                                          
    "---.*?\n",                                                                                                  
    "\\*\\*\\*\\(.*?\\*\\*\\*\\)",                                                                              
    "\\*\\*\\*.*?\n" )); 



################
# main         #
################

# read command line arguments
usage() if (@ARGV < 1 or
    ! GetOptions('help|?' => \$help,
	'pgm=s'     => \$pgm,
	'pmod=s'    => \$pmod,
	'lang=s'   => \$lang,
	'sort=s'    => \$sort_,
	'smod=s'    => \$syntax_module,
	'v|verbose' => \$verbose,
    ) or defined $help );


# check if command line options are set.
# arg_error("Please set all command options; -pgm is not given!") if $pgm eq "?";
# arg_error("Please set all command options; -pmod is not given!") if $pmod eq "?";
# arg_error("Please set all command options; -cfile is not given!") if $lang eq "?";
arg_error("Please set all needed command options; -sort is not given!") if $sort_ eq "?";
# arg_error("Please set all needed command options; -smod is not given!") if $syntax_module eq "?";


##############################
# solve command line options #
##############################
if ($pgm eq "?")
{
    if (-e $ARGV[0])
    {
	$pgm  = $ARGV[0];
    }
    else
    {
	print "If option -pgm is not used then kast program considers the FIRST argument as being the program file. If this file is not found, it returns this error.\n";
	exit(1);
    }
}

my ($fname, $path, $suffix) = fileparse($pgm, qr/\.[^.]*/);
if ($suffix eq "")
{
    print "Cannot infer lang name. Please make sure that $fname has the form \"program_name.lang\" (e.g. helloworld.c).\n \"lang\" (e.g \"c\") is the name of your language; both \"lang.k\" and \"lang-compiled.maude\" must exist.\n";
    exit(1);
}

# 1. program module
$pmod = uc($fname) if ($pmod eq "?");
# 2. compiled file
$suffix =~ s/^\.//;
$lang = $suffix if ($lang eq "?");
# 3. syntax module
$syntax_module = uc($lang) . "-SYNTAX" if ($syntax_module eq "?");

# get the program
local $_ = get_file_content($pgm);
my $temp = $_;

# get tokens
my $dir = dirname($lang);
my $tokens_file = File::Spec->catfile($dir, ".k/all_tokens.tok");
my $tokens = get_file_content($tokens_file);
my @all = split("\n", $tokens);
@all_tokens = split('\s', shift(@all));
@all_syntax = split('\s', shift(@all));

print "Tokens file found ...\n" if $verbose;
print "TOKENS: @all_tokens\n@all_syntax\n\n" if $verbose;
print "Prepare for identifying identifiers ...\n" if $verbose;

# remove comments
s!($comment)!
{
    local $_ = $1;
    s/\S//gs;
    $_;
}!gse;
print "Removed comments ...\n" if $verbose;


# remove strings
s/(?<!\\)".*?(?<!\\)"//sg;
print "Removed strings ...\n" if $verbose;

my @temp = ();
# take care of syntax items
for my $syntax_item (@all_syntax)
{
    my @keywords = split("[^a-zA-Z]+", $syntax_item);
    for my $kwd (@keywords)
    {
	push(@temp, $kwd);
    }
    
    push(@temp, $syntax_item) if !(scalar @keywords > 0);
}

@all_tokens = reverse length_sort(@all_tokens);
@all_syntax = reverse length_sort(@temp);

# print "TOKENS: @all_tokens\n\n@all_syntax\n\nPROGRAM:$_\n\n";

# remove all syntax constructs
for my $syntax_item (@all_syntax)
{
    # remove bounded alpha-characters
    if ($syntax_item =~ /\b[a-zA-Z_]+\b/s)
    {
	s/\b($syntax_item)\b/ /sg;
    }
    
#    print "STEP |$syntax_item| : $_\n\n";
}

# remove tokens (in reversed topological order)
# make sure this is still needed ...
for my $token (@all_tokens)
{
    s/\Q$token\E/ /sg;
}


# collect identifiers
s/\b([a-zA-Z_]+)(?=(\s|$_))/
{
    push (@identifiers, $1);
    "";
}/sge;

# unique Ids
@identifiers = set(@identifiers);

print "Found identifiers: @identifiers\n\n" if $verbose;


##########################
# Creating the K module  #
##########################

$_ = $temp;

# remove extension of program file
$pgm =~ s/\..*$//s;
my $ids = join(" | ", @identifiers);


# remove comments
s!($comment)!
{
    local $_ = $1;
    s/\S//gs;
    $_;
}!gse;



# replace found ids with id("...");
# also use freeze/unfreeze for strings
my @ordered_ids = reverse length_sort(@identifiers);
s/(?<!\\)".*?(?<!\\)"/Freeze($&, "STRINGS")/sge;
for my $id (@ordered_ids)
{
    s/(?<![a-zA-Z_0-9])($id)(?![a-zA-Z_0-9])/id("$1")/sg;
}
$_ = Unfreeze("STRINGS", $_);
    
# create "header"
my $header = "kmod $pmod is including $syntax_module\n\n  syntax $sort_ ::= $pgm\n";
#$header .= "  syntax #Id ::= $ids\n\n  " if $ids ne "";

# Step: append module "header"
s/^/$header
  macro $pgm = ( /s;
 
# Step: append end
s/$/)\n\nendkm/s;

# Step: append load .k/$suffix.maude and -compiled
$_ = "load .k/$lang.maude\n\n$_";


# save in $pgm_cast.k
my $tmp_file = "$pgm\_cast.k";
print "Saving everything in $tmp_file...\n" if $verbose;
open FILE, ">", "$tmp_file" or die "Cannot save in file $tmp_file";
print FILE;
close FILE;
print "Saved.\n\n" if $verbose;

$elapsed = tv_interval ( $t0 );
print "K file created in $elapsed time\n";
$t0 = [gettimeofday];


#################################
# maudify the file              #
#################################

my $output = `kompile -m $tmp_file -flag`;
print "Output: |$output|\n" if $verbose;

$elapsed = tv_interval ( $t0 );
print "K file maudified in $elapsed time\n";
$t0 = [gettimeofday];


#################################
# compile the file              #
#################################

$tmp_file =~ s/\..*$//;

my $pname = $pgm;
my $cfile = "$lang-compiled.maude";
my $cmod = uc($lang);

if (!(-e $cfile))
{
    print "Cannot find the compiled definition ($cfile).\nCompile your definition first.\n";
    exit(1);
}

my $maudified = get_file_content(".k/$tmp_file.maude");
my $compiled =  qx{ sed 2d $cfile};                                                                                           

my $compile =
  "set include PL-BOOL off .
  set include BOOL on .
  load \"$k_tools_dir/" . "prelude-extras\"
  load \"$k_tools_dir/" . "meta-k\"
  
  load  \"$k_tools_dir/" . "compile-program-interface\"
  ---(
      set print attribute on .
      red in COMPILE-PROGRAM-META : compileProgram(\"$pmod\",\"$pname\") .
      q
  ---)
  loop compile-program .
  (compileProgram $pmod $pname .)
  q
  ";

my $tempFile = "programCompile.tmp";
open MYFILE,">",$tempFile or die "Cannot create $tempFile\n";
print MYFILE "load \"$k_prelude\"\n$maudified\n$compile\n";
close(MYFILE);
# push(@generated_files, $tempFile);


$elapsed = tv_interval ( $t0 );
print "Input for compileProgram generated in $elapsed time\n";
$t0 = [gettimeofday];



# run maude with this input
$output = `maude -no-wrap programCompile.tmp`;


$elapsed = tv_interval ( $t0 );
print "compiling the program took $elapsed time\n";
$t0 = [gettimeofday];



if ($output =~ /$begin_compiled_module(.*?)$end_compiled_module/sg)
{
    # save
    my $term = $1;
    $term =~ s/^\s//sg;
    my $name = $pgm;
    open FILE, ">", "$fname.kast" or die "Cannot create $fname.kast\n";
    print FILE $term;
    close FILE;
}
else 
{
    print "Maude (compileProgram) returned no output ...\n";
}

unlink("$tmp_file.k") if !$verbose;
unlink("$tmp_file.maude") if !$verbose;
unlink("programCompile.tmp") if !$verbose;

$elapsed = tv_interval ( $tstart );
print "Total time: $elapsed\n";


# print "$output\n\n\n";



################
# end main     #
################





###########
# utils   #
###########

# print a help message and exit
sub usage
{
    print "Unknown option: @_\n" if @_;
    print "usage: cast [-pgm] program_name [-pmod program_module] [-cfile compiled_file] -sort pgm_sort -smod syntax_module\n\t[-verbose]\n\n
  Options:
  \t-verbose: verbose mode
  \t-pgm    : specify the file where the program is.
  \t-pmod   : specify the name of the module which will wrap the program
  \t-lang   : specify a k compiled file
  \t-sort   : specify program sort
  \t-smod   : specify the syntax module name\n\n";

    exit;
}

# print an error message if arguments not set
sub arg_error
{
    print shift(@_) . "\n";
    usage();
}

# returns file content as string
sub get_file_content                                                                                                              
{                                                                                                                                 
    my $filename = shift;                                                                                                         
    
    open FILEHANDLE, "<", $filename or die "Could not open $filename:\n$!";                                                       
    my @input = <FILEHANDLE>;                                                                                                     
    close FILEHANDLE;                                                                                                             
    
    return join("", @input);                                                                                                      
}

# sorts an array by length of its elements
sub length_sort
{
    sort {length $a <=> length $b} @_;
}

# get set-like array from another array
# get rid of duplicates
sub set
{
    if (@_)
    {
	my %map = map { $_ => 1 } @_;
	return keys %map;
    }
    
    ();
}
