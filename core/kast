#!/usr/bin/env perl

# imports
use strict;
use warnings;
use Getopt::Long;
use File::Spec;
use File::Basename;
use Time::HiRes qw( gettimeofday tv_interval);


use Text::Wrap;
$Text::Wrap::columns = 75;


# specific imports : common_functions.pl
my $namespace = File::Spec->catfile((File::Basename::fileparse($0))[1], 'perl', 'common_functions.pl');
require $namespace;
$namespace = File::Spec->catfile((File::Basename::fileparse($0))[1], 'perl', 'ast.pl');
require $namespace;

my $tstart = [gettimeofday];
my $t0 = [gettimeofday];
my $elapsed = 0;

################
# Variables    #
################

# options
my $help;

my $pgm           = "?";
my $lang          = "?";
my $syntax_module = "?";
my $main_module   = "?";
my $verbose       = 0;
my $out_file      = "?";


# utils
my @all_tokens  = ();
my @all_syntax  = ();
my @identifiers = ();
my $k_tools_dir = File::Spec->catfile((File::Basename::fileparse($0))[1], 'maude','compiler');
my $k_prelude = File::Spec->catfile($k_tools_dir,"..","lib","k-prelude");


# comments
my $comment = join("|", (                                                                                                      
    "\\/\\/.*?(\n|\$)",                     
    "\\/\\*.*?\\*\\/",                                                                                                   
    "---\\(.*?---\\)",                                                                                          
    "---.*?(\n|\$)",                                                                                                  
    "\\*\\*\\*\\(.*?\\*\\*\\*\\)",                                                                              
    "\\*\\*\\*.*?(\n|\$)" )); 



################
# main         #
################

# read command line arguments
error_arg() if @ARGV < 1;

error() if (! GetOptions('help|?' => \$help,
	'pgm=s'      => \$pgm,
	'k-definition=s'     => \$lang,
	'syntax-module=s'     => \$syntax_module,
	'main-module=s'     => \$main_module,
	'o|output=s' => \$out_file,
	'v|verbose'  => \$verbose,
    ));

usage() if defined $help;

##############################
# solve command line options #
##############################
if ($pgm eq "?")
{
    if (defined $ARGV[0] && -e $ARGV[0])
    {
	$pgm  = $ARGV[0];
    }
    else
    {
	print wrap("", "", "If option -pgm is not used then kast program considers the FIRST argument as being the program file. If this file is not found, it returns this error.\n");
	exit(1);
    }
}

my ($fname, $path, $suffix) = fileparse($pgm, qr/\.[^.]*/);
# if ($suffix eq "")
# {
#    print wrap("", "", "Cannot infer lang name. Please make sure that $fname has the form \"program_name.lang\" (e.g. helloworld.c).\n \"lang\" (e.g \"c\") is the name of your language; both \"lang.k\" and \"lang-compiled.maude\" must exist.\n");
#    exit(1);
# }

# 2. compiled file
$suffix =~ s/^\.//;
$lang = $suffix if ($lang eq "?");

if ($lang eq "?" || $lang =~ /^\s*$/sg)
{
    print wrap("", "", "Cannot infer language/definition name.\nPlease try --k-definition option or put an extension to your program.\n");
    exit(1);
}

# print "LANG: $lang\n";
# search for $lang.k
if (!(-e $lang))
{
    if (-e "$lang.k")
    {
	$lang = "$lang.k";
    }
    else
    {
	print wrap("", "", "Cannot find $lang.k! Please make sure $lang.k exists.\n");
	exit(1);
    }
}


# get tokens
my $dir = dirname($lang);
my $tmplang = $lang;
$lang = basename($lang);

if (!(-e $tmplang) || $tmplang !~ /\.k(maude)?/)
{
    print wrap("", "", "Cannot find $tmplang.k!\nPlease make sure $tmplang exists or use option --k-definition.\nType \"kast --help\".\n"); exit;
}

my $tokens_file = File::Spec->catfile($dir, ".k/all_tokens.tok");
my $tokens = get_file_content($tokens_file, wrap("", "", "Please kompile a K defintion before using kast.\nType \"kast --help\".\n"));
my @all = split("\n", $tokens);
@all_tokens = split('\s', shift(@all));
@all_syntax = split('\s', shift(@all));


# remove .k extension
$lang =~ s/\.k(maude)?$//s;



# 3. syntax module
$syntax_module = $main_module . "-SYNTAX" if ($syntax_module eq "?" && $main_module ne "?");
$syntax_module = uc($lang) . "-SYNTAX" if ($syntax_module eq "?");

# message
print "Tokenizing program ... " if $verbose;


##############################################################
#  TOKENIZING
# collect identifiers from program:                          #
# 1. eliminate comments                                      #
# 2. eliminate strings                                       #
# 3. eliminate tokens + keywords from program                #
# 4. collect all left possible identifiers and declare them  #
##############################################################


# get the program
local $_ = get_file_content($pgm, "Please check if $pgm exists!\n");
my $temp = $_;

# remove comments
s!($comment)!
{
    local $_ = $1;
    s/\S//gs;
    $_;
}!gse;


# remove strings
s/(?<!\\)".*?(?<!\\)"//sg;

# syntax contains undescores:
# remove them and keep only keywords
my @temp = ();
for my $syntax_item (@all_syntax)
{
    my @keywords = split("\\b[^a-zA-Z0-9]+\\b", $syntax_item);
#    print "@keywords\n";
    for my $kwd (@keywords)
    {
	push(@temp, $kwd);
    }
    
    push(@temp, $syntax_item) if !(scalar @keywords > 0);
}

@all_tokens = reverse length_sort(@all_tokens);
@all_syntax = reverse length_sort(@temp);

# print "TOKENS: @all_tokens\n\n@all_syntax\n\nPROGRAM:$_\n\n";

# remove syntax
for my $syntax_item (@all_syntax)
{
    $syntax_item =~ s/^_*//;
    $syntax_item =~ s/_*$//;
    my @tmp = reverse length_sort(set(split("_", $syntax_item)));
    my $t   = join ("|", map (quotemeta, @tmp));
    s/\b($t)\b/  /sg if $t !~ /^\s*$/;
}

# remove the rest of tokens (in reversed topological order)
# make sure this is still needed ...
for my $token (@all_tokens)
{
    s/\Q$token\E/ /sg;
}

# collect identifiers
s/\b([a-zA-Z_\$]\w*)\b/
{
    push (@identifiers, $1);
    "";
}/sge;

# make identifiers unique
@identifiers = set(@identifiers);


############################
# end section              #
############################







##############################
# Creating the Maude module  #
# 1. tokenize the program    #
# 2. create a maude module   #
##############################

####################
# 1. tokenization  #
####################
$_ = $temp;

# remove extension of program file
$pgm =~ s/\..*$//s;
my $ids = join(" ", @identifiers);


# remove comments
s!($comment)!
{
    local $_ = $1;
    s/\S//gs;
    $_;
}!gse;


# replace found ids with #id("...");
# also use freeze/unfreeze for strings
my @ordered_ids = reverse length_sort(@identifiers);
s/(?<!\\)".*?(?<!\\)"/Freeze($&, "STRINGS")/sge;
for my $id (@ordered_ids)
{
    s/(?<![a-zA-Z_0-9])($id)(?![a-zA-Z_0-9])/#id\_("$1")/sg;
}

# freeze also the construct #id("identifier")
s/#id\_\((?<!\\)".*?(?<!\\)"\)/Freeze($&, "STRINGS")/sge;

# spacify
my @tks = (@all_tokens, @all_syntax);
$_ = spacify($_, @tks);

# unfreeze everything
$_ = Unfreeze("STRINGS", $_);
# print "PROGRAM:\n$_\n\n";


#################################
# kasting                       #
#################################

my $to_reduce = "mod TEST-DO-NOT-USE-THIS-NAME is including $syntax_module .
  sort ParsedPrm .
  op parse_ : Universal -> ParsedPrm [poly(1)] .
endm
  
set print mixfix off .
red parse( $_ ) .
q";


my $to_load = File::Spec->catfile($dir, ".k\/$lang.maude"); 

# prepare maude input
my $tempFile = "programCompile.maude";
open MYFILE,">",$tempFile or die "Cannot create $tempFile\n";
print MYFILE "load $k_prelude\nload $to_load\n$to_reduce\n";
close(MYFILE);
# push(@generated_files, $tempFile);

$elapsed = tv_interval ( $t0 );
print "DONE [" . sprintf("%.3f", $elapsed) . "s]\n" if $verbose;
$t0 = [gettimeofday];
print "Kasting program ...... " if $verbose;

my $xml_ast = "ast.xml";

# run maude with this input
my $output = `maude -no-wrap programCompile.maude -xml-log=$xml_ast`;

# get ast
my $ast = get_ast($xml_ast);

# time
$elapsed = tv_interval ( $t0 );
print "DONE [" . sprintf("%.3f", $elapsed) . "s]\n" if $verbose;
$t0 = [gettimeofday];

# clean
unlink("programCompile.maude") if !$verbose;
unlink($xml_ast) if !$verbose;


$out_file = "/dev/stdout" if $out_file eq "?";
# saving
open FILE, ">", "$out_file" or die "Cannot create $out_file\n";
print FILE $ast;
close FILE;


$elapsed = tv_interval ( $tstart );
print "Total time ........... DONE [" . sprintf("%.3f", $elapsed) . "s]\n\n" if $verbose;



################
# end main     #
################





###########
# utils   #
###########

# an attempt to tokenize a program
sub spacify
{
    local $_ = shift;
    my @tokens = @_;
    
    my @temp = @tokens;
    @tokens = ();
    for my $tok (@temp)
    {
	my @keywords = split("_", $tok);
	for my $kwd (@keywords)
	{
	    push(@tokens, $kwd) if $kwd ne "";
	}
    }

    @tokens = reverse length_sort(set(@tokens));
    
    my @tkz = ();
    for my $tok (@tokens)
    {
	if ($tok ne ";")
	{
	    push(@tkz, quotemeta($tok));
	}
	else
	{
	    push(@tkz, $tok);
	}
    }
    
    my $tokens_pattern = join("|", @tkz);

    s/($tokens_pattern)/ $1 /sg;

    $_;
}


# print a help message and exit
sub usage_tmp
{
# 12345678123456781234567812345678123456781234567812345678123456781234567812345678
    print "Usage: kast [--pgm] program_name [options] \n\n
Options:
  --pgm <pgm>              : specifies the file where the program is
  --k-definition <def>     : specifies the K definition
                               The `.k` extension is optional. 
                               The default value of <def> is <pgm> extension
  --main-module <module>   : specifies the main module name
                               The default value is <DEF> (capitalized K 
			          definition name)
  --syntax-module <module> : specifies the syntax module name
                               The default value is <DEF>-SYNTAX.
                               If --main-module is used then <module> 
                               is <main-module>-SYNTAX
  --output <file>          : set <file> as being the output file
                               The default value is /dev/stdout
  --verbose                : verbose mode\n
The definition is assumed to have been kompiled prior to calling kast.\n\n";
exit;
}


sub usage
{
# 12345678123456781234567812345678123456781234567812345678123456781234567812345678
    print "Usage: kast [OPTIONS] <file>
  
Parses program to a K abstract syntax tree (abbreviated kast) using default
parser.  The K definition is assumed to have been kompiled prior to calling
kast (see kompile for instructions on how to kompile K definitions).
  
OPTIONS:
  
    --k-definition=FILE      Path to main .k file of the K definition.
                             `.k` extension is optional. 
                               
    --main-module=STRING     Main module in the K definition.
                             Default: uppercase(`basename <k-definition> .k`)
  
    --syntax-module=STRING   Syntax module in the K definition. 
                             Default: <main-module>-SYNTAX\n";

exit;
}

sub error_arg
{
    print "kast: missing <program> argument\nType `kast --help` for more information.\n";
    exit;
}

sub error
{
    print "Type `kast --help` for more information.\n";
    exit;
}

# returns file content as string
sub get_file_content
{
    my $filename = shift;
    my $rest = "@_";
    
    open FILEHANDLE, "<", $filename or die "Could not open $filename:\n$!\n$rest";
    my @input = <FILEHANDLE>;
    close FILEHANDLE;

    return join("", @input);
}

# sorts an array by length of its elements
sub length_sort
{
    sort {length $a <=> length $b} @_;
}

# get set-like array from another array
# get rid of duplicates
sub set
{
    if (@_)
    {
	my %map = map { $_ => 1 } @_;
	return keys %map;
    }
    
    ();
}
