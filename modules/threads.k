require seq

module THREADS imports SEQ
  configuration <thread multiplicity="*"> 
                  <k> .K </k> <holds> .Map </holds>
                </thread>
                <busy> .Set </busy>
  syntax K ::= spawn K       [prec 90]
             | acquire K     [strict]
             | release K     [strict]
             | rendezvous K  [strict]
             | Nat

  rule [spawn-thread] : 
       <thread>... <k>spawn S:K 
                      => skip ...</k>  ...</thread>
       (. => <thread>...  <k>S</k>  ...</thread>) [transition]

  rule [end-thread] : 
       (<thread>...  <k>V:KResult</k> <holds>Holds:Map</holds>        
        ...</thread> => .) <busy>Busy:Set 
                                 => Busy -Set keys(Holds)</busy> [transition]

  rule [free-acquire] : 
       <k>acquire V 
          => skip ...</k> <holds>... . 
                                     => V|->0 ...</holds> 
       <busy>Busy (.
                   => SetItem(V))</busy>
    when notBool(V in Busy) [transition]
  rule [reentrant-acquire] : 
       <k>acquire V 
          => skip ...</k> <holds>... V|->(N:Nat 
                                          => N +Int 1) ...</holds>

  rule [reentrant-release] : 
       <k>release V 
          => skip ...</k> <holds>... V|->(N 
                                          => N -Int 1) ...</holds>
    when N >Int 0

  rule [release] : 
       <k>release V 
          => skip ...</k> <holds>... (V|->0 
                                      => .) ...</holds> 
       <busy>... (SetItem(V)
            => .) ...</busy>

  rule [rendezvous] : 
       <k>rendezvous V 
          => skip ...</k> <k>rendezvous V 
                             => skip ...</k>  [transition]
end module
