load add-eval

mod ADD-EVAL-META is
  including ADD-EVAL .
  including META-LEVEL-EXTRAS .
  including META-K-MODULES .
  including META-K-BUILTINS .
  including COMPILATION-ATTRS .
  including K-META-CONFIG .

  var NoAddEval AddEval : String .
  var Q QNoAddEval QAddEval : Qid .
  var M : Module . var MS : ModuleSet .
  op addEval : String String ~> Module .
  eq addEval(NoAddEval, AddEval) = addEval(qid(NoAddEval), qid(AddEval)) .
  op addEval : Qid Qid ~> Module .
  eq addEval(QNoAddEval,QAddEval) 
   = setName(compileADD-EVAL(upModule(QNoAddEval, false), none), QAddEval) .

  var T : [Term] . 
  op addEvalTestConf : Qid Module Term ~> Module .
  eq addEvalTestConf(QNoAddEval, M, T) 
   = addEval(QNoAddEval, M, if T :: Term then T else defaultConfig fi) .

  op compileADD-EVAL : Module AttrSet ~> Module .
  eq compileADD-EVAL(M, AS:AttrSet) = addEvalTestConf(getName(M), M, extractConfTerm(M)) .
endm

mod ADD-EVAL-LOOP is 
  including LOOP-MODE + META-LEVEL .
  including MODULE-META-PRETTY-PRINT .
  op add-eval : -> System .
  op idle : -> State .
  var Q NoAddEval AddEval : Qid . var QIL QIL' : QidList . var FM : Module .
  eq add-eval = [nil, idle, 
 'Usage: 'addEval '<Name> '<Suffix> '.] .


  op wrapper : Qid -> Module .
  eq wrapper(Q) = (mod 'MKKR is including Q . 
                    sorts none . none none none none none endm) .
  op error : -> [Module] .
  op print : Module [Module] -> QidList .
  var Str : String . var M FM' : Module .
  eq print(M,FM) = eMetaPrettyPrint(setRls(setEqs(FM,none),none), FM) [owise] .
  crl ['addEval NoAddEval AddEval QIL, idle, QIL'] 
   => [QIL, idle, print(upModule(NoAddEval,false), FM )] 
   if FM := downTerm(getTerm(
             metaReduce(wrapper('ADD-EVAL-META),
                        'addEval[upTerm(string(NoAddEval)),upTerm(string(AddEval))])),error) .
endm
