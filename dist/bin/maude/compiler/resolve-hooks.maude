mod RESOLVE-HOOKS is 
  including CONVERSION .
  including META-MODULE-EXTRAS .
  including NAT-LIST-EXTRAS .
  including STRICT-ATTRS .
  including K-STRICTNESS-OPS .
  including META-K-CONTEXTS .
  including K-SORTS .
  including META-K-LABELS .
  including K-META-LISTS .
  including METADATA-EXTRAS .
  including PARSE-METADATA .
  var Str : String .   
  var AS AS' : AttrSet .  var Terms : TermList .  var V : Variable .
  var Q Q' QO QM : Qid . var QIL : QidList .
  var Ty : Type . var Tyl : TypeList . 
  var Op : OpDecl . var OPDS : OpDeclSet . var M : Module .
  var I : Qid . var IL : ImportList .
  var HL : HookList . var H : Hook .
  var N : Nat .

  op resolveHooks : Qid Module ~> Module .
  eq resolveHooks(Q, M) 
   = setImports(addEqs(resolveHooksOps(getOps(M)), M),replaceInterfaces(getImports(M))) [print "resolveHooks: " M] .


  op replaceInterfaces : ImportList -> ImportList .
  eq replaceInterfaces((including I .) IL)
   = (including replaceInterface(I) .) replaceInterfaces(IL) .
  eq replaceInterfaces(nil) = nil .

  op replaceInterface : Qid -> Qid .
  eq replaceInterface(Q) = qid(replace(string(Q), "-INTERFACE", "")) .

  op resolveHooksOps : OpDeclSet ~> EquationSet .
  eq resolveHooksOps(none) = none .
  eq resolveHooksOps(Op OPDS) = resolveHooksOp(Op) resolveHooksOps(OPDS) .

 op resolveHooksOp : OpDecl ~> EquationSet .
  eq resolveHooksOp(op Q : nil -> Ty [AS metadata(Str)] .)
   = resolveHooksOp(op Q : nil -> Ty [AS metadataParse(Str)] .) .
  eq resolveHooksOp(op Q : nil -> Ty [AS pair("hook",Str)] .)
   = resolveHooks(Q, AS, parseHooks(Str)) [print "parsing '" Str "' hooks for " Q] .
  eq resolveHooksOp(Op) = none [owise print "did not find any hook for " Op] .

  op resolveHooks : Qid AttrSet HookList -> EquationSet .
  eq resolveHooks(Q, AS, nil) = none .
  eq resolveHooks(Q, AS, H HL) 
   = resolveHook(Q, AS, H) resolveHooks(Q, AS, HL) .
  
  op resolveHook : Qid AttrSet Hook -> Equation .
  eq resolveHook(Q, AS, hookOp(QM, QO))
   = resolveHook(Q, AS, upModule(QM, true), QO) .

  op resolveHook : Qid AttrSet Module Qid -> Equation .
  eq resolveHook(Q, AS karity(N), M, QO) 
   = resolveHook(Q, AS karity(N), maximalArityOp(M, getNamedOps(M,QO), N)) .
  eq resolveHook(Q, AS, M, QO) 
   = resolveHook(Q, AS, maximalArityOp(M, getNamedOps(M,QO))) [owise] .

  op resolveHook : Qid AttrSet OpDecl -> Equation .
  eq resolveHook(Q, AS, op QO : Tyl -> Ty [AS'] .)
   = resolveHook(Q, AS, QO, genVars(Tyl,"Hk"),  Ty) .
  eq resolveHook(Q, AS, errorOp(Str:String,AS'))
   = errorEq('`[`]:K,"",Str + " while looking up hooks for " + string(Q) + ".",AS) .

  op resolveHook : Qid AttrSet Qid TermList Type -> Equation .
  eq resolveHook(Q, AS, QO, Terms,  Ty) 
   = (eq kApply(mkConstant(Q,KLabel), mkKList(Terms))
       =  kApply(mkSubsortWrapper(Ty,KLabel)[QO[Terms]],nilKList) [metadata(removeOpAttrs(AS) pair("hook",string(QO)))] .) .

  op mkKList_ : TermList ~> TermList .
  eq mkKList(empty) = empty .
  eq mkKList(V, Terms) 
   = if getType(V) == K 
        then V 
        else kApply(mkSubsortWrapper(getType(V),KLabel)[V],nilKList) 
     fi, mkKList(Terms) .

  op parseHooks : String -> HookList .
  eq parseHooks(Str) = parseHooks(tokenize(stripSpaces(Str))) .

  op parseHooks : QidList -> HookList .
  eq parseHooks(Q QIL) = hookOp(getName(Q),getType(Q)) parseHooks(QIL) .
  eq parseHooks((nil).QidList) = nil .


  op hookOp : Qid Qid -> Hook .
endm

