K Tutorial --- LAMBDA --- Selective Strictness, Anonymous Variables
by Grigore Rosu

We here show how to define selective strictness to language constructs,
that is, how to state that certain language constructs are strict only
in some arguments.  In passing, we also show how to use anonymous variables.

We do this by means of a conditional construct, which takes three arguments,
evaluates only the first one, and then reduces to either the second or the
third, depending on whether the first one evaluated to true or to false.

K allows to define selective strictness using the same "strict" attribute,
but passing it a list of numbers.  The numbers correspond to the arguments
in which we want the defined construct to be strict.  In our case,

  syntax Exp ::= "if" Exp "then" Exp "else" Exp   [strict(1)]

states that the conditional construct is strict in the first argument.

We can now assume that its first argument will eventually reduce to a value, so
we only write the following two semantic rules:

  rule if true  then E else _ => E
  rule if false then _ else E => E

Thus, we assume that the first argument evaluates to either "true" or "false".

Note the use of the anonymous variable "_".  We use such variables purely for
structural reasons, to state that something is there but we don't care what.
An anonymous variable is therefore completely equivalent to a normal variable
which is unsorted and different from all the other variables in the rule.  If
you use "_" multiple times in a rule, they will all be considered distinct.

Compile lambda.k and write some interesting programs.  As an example, here
is a program calculating the factorial of 100:

let f = lambda x . (
          (lambda t . lambda x . (t t x))
          (lambda f . lambda x . if (x <= 1) then 1 else (x * (f f (x + -1))))
          x
        )
in (f 100)

This program follows a common technique to define fixed points in untyped
lambda calculus, based on passing a function to itself.

We may not like to define fixed points following the approach above, because
it requires global changes in the body of the function meant to be recursive,
basically to pass it to itself ("f f" in our case above).  The approach below
isolates the fixed point aspect of the function in a so-called "fixed point
combinator", which we call "fix" below, and then apply it to the function
defining the body of the factorial, without any changes to it:

let fix = lambda f . (
            (lambda x . (f (lambda y . (x x y))))
            (lambda x . (f (lambda y . (x x y))))
          )
in let f = fix (lambda f . lambda x . if x <= 1 then 1 else (x * (f (x + -1))))
   in (f 10)

While the above techniques are interesting and powerful (untyped lambda
calculus is in fact Turing complete), programmers will likely not like to
write programs this way.  In the next lesson we will introduce a new language
construct, called letrec and conventionally found in functional programming
languages, whose semantics will capture the fixed-point idea above.
