K Tutorial --- LAMBDA --- Derived Constructs
by Grigore Rosu

When defining a language, we often want certain language constructs to be
defined in terms of other constructs.  For example, a let-binding construct
of the form

  let x = e in e'

is nothing but syntactic sugar for

  (lambda x . e') e

This can be easily achieved with a rule, as shown in lambda.k.

As a side point, which is not very relevant here, we may want the "desugaring"
of let to not even count as a computational step, but as a mere "structural
rearangement" of the program so that other semantics rules (beta reduction,
in our case) can match and apply.

The K tool allows us to tag rules with the attribute "structural", with
precisely the intuition above.  You can think of structural rules as a kind
of light rules, almost like macros, or like ones which apply "under the hood",
instanteneously.  There are several other uses for structural rules in K,
which we will discuss later in this tutorial.

Compile lambda.k and write some programs using let binders.

In the next lecture we will define the conditional construct, which together
with the let binder will allow us to write interesting programs.


----------------- from lambda06 ----------------


  As an example, here
is a program calculating the factorial of 100:

let f = lambda x . (
          (lambda t . lambda x . (t t x))
          (lambda f . lambda x . if (x <= 1) then 1 else (x * (f f (x + -1))))
          x
        )
in (f 100)

This program follows a common technique to define fixed points in untyped
lambda calculus, based on passing a function to itself.

We may not like to define fixed points following the approach above, because
it requires global changes in the body of the function meant to be recursive,
basically to pass it to itself ("f f" in our case above).  The approach below
isolates the fixed point aspect of the function in a so-called "fixed point
combinator", which we call "fix" below, and then apply it to the function
defining the body of the factorial, without any changes to it:

let fix = lambda f . (
            (lambda x . (f (lambda y . (x x y))))
            (lambda x . (f (lambda y . (x x y))))
          )
in let f = fix (lambda f . lambda x . if x <= 1 then 1 else (x * (f (x + -1))))
   in (f 10)

While the above techniques are interesting and powerful (untyped lambda
calculus is in fact Turing complete), programmers will likely not like to
write programs this way.  In the next lesson we will introduce a new language
construct, called letrec and conventionally found in functional programming
languages, whose semantics will capture the fixed-point idea above.
