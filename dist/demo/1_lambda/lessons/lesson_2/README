K Tutorial --- LAMBDA --- Module Importing, Rules, Variables
by Grigore Rosu

We here learn how to include a predefined module (SUBSTITUTION), how to
use it to define a K rule (the characteristic rule of lambda calculus),
and how to make proper use of variables in rules.

The "requires" keyword takes a .k file containing language features that are
needed for the current definitions.  The predefined features are referred to
using their relative path from the k/include folder.  Thus, the command

  require "modules/substitution.k"

says that the subsequent definition of LAMBDA needs the generic substitution,
which is predefined in file modules/substitution.k under the folder k/include.

Import in LAMBDA (using the "imports" keyword) the module SUBSTITUTION, which
is defined in the required substitution.k file.

Now we have all the substitution machinery available for our definition.
However, since our substitution is generic, it cannot know which language
constructs bind variables; however, this information is critical in order to
correctly solve the variable capture problem.  Thus, you have to tell the
substitution that your lambda construct is meant to be a binder.  This is
simply done using the attribute "binder".

Now we are ready to define the beta-reduction rule of lambda calculus,
making use of substitution in its right-hand side, as shown in lambda.k.
By convention, variables that appear in rules start with a capital letter
(the current implementation of the K tool may even enforce that).

Variables may be tagged by users with their syntactic category (also called
"sort"), or not.  If tagged, the matching term will be checked at runtime for
membership to the claimed sort.  It not tagged, then no check will be made.
The former is safer, but involves the generation of a side condition to the
rule, so it may be slightly slower overall.

In our rule in lambda.k we tagged all variables with their sorts, so we chose
the safest path.  Only the V variable really needs to be tagged there,
because we can prove (using other means, not the K tool, as the K tool is not
concerned with proving) that the first two variables will always have the
claimed sorts whenever we execute any expression that parses within our
original grammar.

Compile the definition and then run some programs.

First, you will notice that a new cell has been automatically added to the
default configuration.  For example,

  krun variable_capture.lambda

yields the output

 <k>
  lambda _id0 . ((lambda x . (lambda y . (x  y)))  _id0) 
 </k> 
 <nextId>
  1 
 </nextId> 

The new cell <nextId> ... </nextId> has been added by the substitution,
to keep track of the fresh variables that it needs to generate in order to
avoid variable capture.  In our example above, it has already used a fresh
identifier, _id0, and thus the counter has been incremented (from 0 to 1).

Second, you will notice that only certain programs reduce (some even yield
non-termination, such as omega.lambda), while others do not.  This is because
the K rewrite rules between syntactic terms do not apply anywhere they match.
They only apply where they have been given permission to apply by means of
appropriate evaluation strategies of language constructs, which is done using
strictness attributes, evaluation contexts, heating/cooling rules, etc., as
discussed in the next lessons.

The next lesson will show how to add LAMBDA the desired evaluation strategies.
