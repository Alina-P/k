Blind Reuse Does Not Always Work!

Let's try (and fail) to reuse the definition of callcc from lesson_1:

  syntax Exp ::= "callcc" Exp  [strict]
  syntax Val ::= cc(K)
  rule <k> (callcc V:Val => V cc(K)) ~> K </k>
  rule <k> cc(K) V ~> _ =>  V ~> K </k>

The callcc examples so far work, so it may look it works.
However, the problem is that cc(K) should also include an environment,
and that it should restore it when invoked together with the enclosed K.
Let's try to illustrate this bug with callcc-env1.lambda, where the
second argument of +, x, should be bound to the top x, which is 1.
However, since callcc does not restore the environment, that x should
be looked up in the wrong, callcc-inner environment, so we should see the
overall result 44.

Hm, we get the right result, 3 ... This sort of thing is quite annoying when
it happens.  So, why do we get 3?  Well, recall that + is strict, which means
that it can evaluate its arguments in any order.  It just happened that in the
execution that we saw, its second argument was evaluated first, to 1, and then
the callcc was evaluated, but its cc value K had already included the 1 instead
of x ...  In Tutorial 3 we will see how to explore all non-deterministic 
behaviors of a program; we could use that feature of K to debug semantics, too,
like we would use it here.

There are two simple ways to fix this problem and thus illustrate the semantic
problem that we have here.  One is to make + seqstrict in the semantics, to
enforce its evaluation from left-to-right.  Do it an convince yourself that
the program evaluates to 4 then.  Another is to modify the program, to
enforce the left-to-right evaluation order using let binders;
see callcc-env2.lambda.  Now we also get 4.
