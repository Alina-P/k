module Program

imports Common
imports KBuiltinsBasic
exports

context-free syntax
context-free priorities
{ left:
	"if" InsertDzExp "then" InsertDzExp "else" Exp -> Exp {cons("Exp1284Syn")}
	Exp Exp -> Exp {left, cons("Exp1285Syn")}
} > { left:
	"mu" InsertDzId "." Exp -> Exp {cons("Exp1286Syn")}
	"lambda" InsertDzId "." Exp -> Exp {cons("Exp1287Syn")}
	"let" InsertDzId "=" InsertDzExp "in" Exp -> Exp {cons("Exp1288Syn")}
	"letrec" InsertDzId InsertDzId "=" InsertDzExp "in" Exp -> Exp {cons("Exp1289Syn")}
} > { left:
	Exp "+" Exp -> Exp {cons("Exp1290Syn")}
	Exp "-" Exp -> Exp {cons("Exp1292Syn")}
} > { left:
	Exp "*" Exp -> Exp {cons("Exp1293Syn")}
	Exp "/" Exp -> Exp {cons("Exp1294Syn")}
	Exp "%" Exp -> Exp {cons("Exp1295Syn")}
	"-" Exp -> Exp {cons("Exp1296Syn")}
} > { non-assoc:
	Exp "<" Exp -> Exp {cons("Exp1297Syn")}
	Exp "<=" Exp -> Exp {cons("Exp1298Syn")}
	Exp ">" Exp -> Exp {cons("Exp1299Syn")}
	Exp ">=" Exp -> Exp {cons("Exp1300Syn")}
	Exp "==" Exp -> Exp {cons("Exp1302Syn")}
	Exp "!=" Exp -> Exp {cons("Exp1303Syn")}
} > { right:
	Exp "and" Exp -> Exp {cons("Exp1304Syn")}
	Exp "or" Exp -> Exp {cons("Exp1305Syn")}
	"not" Exp -> Exp {cons("Exp1306Syn")}
}

context-free start-symbols
	Start
context-free syntax
	DzBool -> Bool
	DzLTLFormula -> LTLFormula
	DzFloat -> Float
	DzInt -> Int
	DzString -> String
	DzModelCheckerState -> ModelCheckerState
	DzProp -> Prop
	DzModelCheckResult -> ModelCheckResult
	Prop -> LTLFormula
	DzId -> Id
	"(" Exp ")" -> Exp {bracket}
	Int -> Exp
	Bool -> Exp
	Id -> Exp
	Exp -> InsertDzExp
	Id -> InsertDzId

%% start symbols
	Float		-> Start
	Exp		-> Start
	LTLFormula		-> Start
	Bool		-> Start
	Prop		-> Start
	String		-> Start
	Id		-> Start
	ModelCheckResult		-> Start
	Int		-> Start
	ModelCheckerState		-> Start


	DzDzInt		-> DzInt	{cons("DzInt1Const")}
	DzDzBool	-> DzBool	{cons("DzBool1Const")}
	DzDzId		-> DzId		{cons("DzId1Const")}
	DzDzString	-> DzString	{cons("DzString1Const")}

	DzDzINT		-> DzDzInt
	DzDzID		-> DzDzId
	DzDzBOOL	-> DzDzBool
	DzDzSTRING	-> DzDzString

lexical syntax


	"lambda" -> DzDzID {reject}
	"if" -> DzDzID {reject}
	"else" -> DzDzID {reject}
	"let" -> DzDzID {reject}
	"or" -> DzDzID {reject}
	"mu" -> DzDzID {reject}
	"in" -> DzDzID {reject}
	"letrec" -> DzDzID {reject}
	"and" -> DzDzID {reject}
	"not" -> DzDzID {reject}
	"then" -> DzDzID {reject}

lexical restrictions
	%% follow restrictions

