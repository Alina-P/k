module Integration

imports Common
imports KTechnique
imports KBuiltinsBasic

exports

context-free syntax
context-free priorities
{
	"notBool" Bool -> Bool {left, cons("Bool10Syn")}
} > {
	Bool "andBool" Bool -> Bool {left, cons("Bool1AndBoolSyn")}
	Bool "andThenBool" Bool -> Bool {left, cons("Bool12Syn")}
} > {
	Bool "xorBool" Bool -> Bool {left, cons("Bool13Syn")}
} > {
	Bool "orBool" Bool -> Bool {left, cons("Bool14Syn")}
	Bool "orElseBool" Bool -> Bool {left, cons("Bool15Syn")}
} > {
	Bool "impliesBool" Bool -> Bool {left, cons("Bool16Syn")}
} > { left:
	Bool "==Bool" Bool -> Bool {left, cons("Bool17Syn")}
	Bool "=/=Bool" Bool -> Bool {left, cons("Bool18Syn")}
}

context-free priorities
{ left:
	Int "*Int" Int -> Int {left, cons("Int19Syn")}
	Int "/Int" Int -> Int {left, cons("Int120Syn")}
	Int "%Int" Int -> Int {left, cons("Int122Syn")}
} > { left:
	Int "+Int" Int -> Int {left, cons("Int123Syn")}
	Int "-Int" Int -> Int {left, cons("Int124Syn")}
}

context-free priorities
{ left:
	Float "*Float" Float -> Float {left, cons("Float135Syn")}
	Float "/Float" Float -> Float {left, cons("Float136Syn")}
	Float "%Float" Float -> Float {left, cons("Float137Syn")}
} > { left:
	Float "+Float" Float -> Float {left, cons("Float138Syn")}
	Float "-Float" Float -> Float {left, cons("Float139Syn")}
}

context-free priorities
{ left:
	Float "<=Float" Float -> Bool {left, cons("Bool140Syn")}
	Float "<Float" Float -> Bool {left, cons("Bool142Syn")}
	Float ">=Float" Float -> Bool {left, cons("Bool143Syn")}
	Float ">Float" Float -> Bool {left, cons("Bool144Syn")}
	Float "==Float" Float -> Bool {left, cons("Bool145Syn")}
	Float "=/=Float" Float -> Bool {left, cons("Bool146Syn")}
}

context-free priorities
{ left:
	K "==K" K -> Bool {cons("Bool1EqEqKSyn")}
	K "=/=K" K -> Bool {cons("Bool168Syn")}
}

context-free priorities
{
	"++" Exp -> Exp {cons("Exp1295Syn")}
	Exp "instanceOf" Id -> Exp {cons("Exp1296Syn")}
	"cast" InsertDzExp "to" Id -> Exp {cons("Exp1297Syn")}
	Exp "." Id -> Exp {cons("Exp1299Syn")}
} > {
	Exp "[" InsertDzExps "]" -> Exp {cons("Exp1300Syn")}
} > {
	Exp "(" InsertDzExps ")" -> Exp {cons("Exp1302Syn")}
	"-" Exp -> Exp {cons("Exp1303Syn")}
} > { left:
	Exp "*" Exp -> Exp {left, cons("Exp1306Syn")}
	Exp "/" Exp -> Exp {left, cons("Exp1307Syn")}
	Exp "%" Exp -> Exp {left, cons("Exp1308Syn")}
} > { left:
	Exp "+" Exp -> Exp {left, cons("Exp1309Syn")}
	Exp "-" Exp -> Exp {left, cons("Exp1320Syn")}
} > { non-assoc:
	Exp "<" Exp -> Exp {non-assoc, cons("Exp1322Syn")}
	Exp "<=" Exp -> Exp {non-assoc, cons("Exp1323Syn")}
	Exp ">" Exp -> Exp {non-assoc, cons("Exp1324Syn")}
	Exp ">=" Exp -> Exp {non-assoc, cons("Exp1325Syn")}
	Exp "==" Exp -> Exp {non-assoc, cons("Exp1326Syn")}
	Exp "!=" Exp -> Exp {non-assoc, cons("Exp1327Syn")}
} > {
	"not" Exp -> Exp {cons("Exp1328Syn")}
} > { left:
	Exp "and" Exp -> Exp {left, cons("Exp1329Syn")}
	Exp "or" Exp -> Exp {left, cons("Exp1330Syn")}
} > {
	Exp "=" Exp -> Exp {right, cons("Exp1332Syn")}
	Exp DouaPuncteDz Type -> Exp {cons("Exp1333Syn")}
}

%% subsorts 1
context-free priorities
{
	Types -> K
	Bool -> K
	Ddecl -> K
	Type -> K
	DzId -> K
	Stmts -> K
	ModelCheckResult -> K
	Vals -> K
	KResult -> K
	DzFloat -> K
	TCPAnswer -> K
	DzString -> K
	Exp -> K
	DzInt -> K
	Prop -> K
	DzModelCheckerState -> K
	DzLTLFormula -> K
	Int -> K
	DzModelCheckResult -> K
	DzBool -> K
	Exps -> K
	DzProp -> K
	ModelCheckerState -> K
	Float -> K
	Nat -> K
	Char -> K
	LTLFormula -> K
	String -> K
	Stmt -> K
	Val -> K
	Id -> K
} > {
	Int -> Val
	String -> TCPAnswer
	DzFloat -> Float
	DzLTLFormula -> LTLFormula
	DzModelCheckResult -> ModelCheckResult
	Stmt -> Stmts
	Int -> Exp
	Exp -> Exps
	Val -> Exp
	DzBool -> Bool
	DzModelCheckerState -> ModelCheckerState
	DzId -> Id
	Val -> Vals
	DzString -> String
	Type -> Types
	Ddecl -> Stmts
	Id -> Exp
	DzInt -> Int
	DzProp -> Prop
	Prop -> LTLFormula
	Val -> KResult
	String -> Val
	String -> Exp
	Bool -> Val
	Bool -> Exp
} > {
	K -> Types
	K -> Bool
	K -> Ddecl
	K -> Type
	K -> DzId
	K -> Stmts
	K -> ModelCheckResult
	K -> Vals
	K -> KResult
	K -> DzFloat
	K -> TCPAnswer
	K -> DzString
	K -> Exp
	K -> DzInt
	K -> Prop
	K -> DzModelCheckerState
	K -> DzLTLFormula
	K -> Int
	K -> DzModelCheckResult
	K -> DzBool
	K -> Exps
	K -> DzProp
	K -> ModelCheckerState
	K -> Float
	K -> Nat
	K -> Char
	K -> LTLFormula
	K -> String
	K -> Stmt
	K -> Val
	K -> Id
}

%% subsorts 2
context-free priorities
{
	K -> Types
} .> {
	Types -> K
	Type -> K
}

context-free priorities
{
	K -> Bool
} .> {
	Bool -> K
	DzBool -> K
}

context-free priorities
{
	K -> Ddecl
} .> {
	Ddecl -> K
}

context-free priorities
{
	K -> Type
} .> {
	Type -> K
}

context-free priorities
{
	K -> DzId
} .> {
	DzId -> K
}

context-free priorities
{
	K -> Stmts
} .> {
	Ddecl -> K
	Stmts -> K
	Stmt -> K
}

context-free priorities
{
	K -> ModelCheckResult
} .> {
	ModelCheckResult -> K
	DzModelCheckResult -> K
}

context-free priorities
{
	K -> Vals
} .> {
	Bool -> K
	Vals -> K
	DzString -> K
	DzInt -> K
	Int -> K
	DzBool -> K
	String -> K
	Val -> K
}

context-free priorities
{
	K -> KResult
} .> {
	Bool -> K
	KResult -> K
	DzString -> K
	DzInt -> K
	Int -> K
	DzBool -> K
	String -> K
	Val -> K
}

context-free priorities
{
	K -> DzFloat
} .> {
	DzFloat -> K
}

context-free priorities
{
	K -> TCPAnswer
} .> {
	TCPAnswer -> K
	DzString -> K
	String -> K
}

context-free priorities
{
	K -> DzString
} .> {
	DzString -> K
}

context-free priorities
{
	K -> Exp
} .> {
	Bool -> K
	DzId -> K
	DzString -> K
	Exp -> K
	DzInt -> K
	Int -> K
	DzBool -> K
	String -> K
	Val -> K
	Id -> K
}

context-free priorities
{
	K -> DzInt
} .> {
	DzInt -> K
}

context-free priorities
{
	K -> Prop
} .> {
	Prop -> K
	DzProp -> K
}

context-free priorities
{
	K -> DzModelCheckerState
} .> {
	DzModelCheckerState -> K
}

context-free priorities
{
	K -> DzLTLFormula
} .> {
	DzLTLFormula -> K
}

context-free priorities
{
	K -> Int
} .> {
	DzInt -> K
	Int -> K
}

context-free priorities
{
	K -> DzModelCheckResult
} .> {
	DzModelCheckResult -> K
}

context-free priorities
{
	K -> DzBool
} .> {
	DzBool -> K
}

context-free priorities
{
	K -> Exps
} .> {
	Bool -> K
	DzId -> K
	DzString -> K
	Exp -> K
	DzInt -> K
	Int -> K
	DzBool -> K
	Exps -> K
	String -> K
	Val -> K
	Id -> K
}

context-free priorities
{
	K -> DzProp
} .> {
	DzProp -> K
}

context-free priorities
{
	K -> ModelCheckerState
} .> {
	DzModelCheckerState -> K
	ModelCheckerState -> K
}

context-free priorities
{
	K -> Float
} .> {
	DzFloat -> K
	Float -> K
}

context-free priorities
{
	K -> Nat
} .> {
	Nat -> K
}

context-free priorities
{
	K -> Char
} .> {
	Char -> K
}

context-free priorities
{
	K -> LTLFormula
} .> {
	Prop -> K
	DzLTLFormula -> K
	DzProp -> K
	LTLFormula -> K
}

context-free priorities
{
	K -> String
} .> {
	DzString -> K
	String -> K
}

context-free priorities
{
	K -> Stmt
} .> {
	Stmt -> K
}

context-free priorities
{
	K -> Val
} .> {
	Bool -> K
	DzString -> K
	DzInt -> K
	Int -> K
	DzBool -> K
	String -> K
	Val -> K
}

context-free priorities
{
	K -> Id
} .> {
	DzId -> K
	Id -> K
}

context-free syntax
	DzBool -> Bool
	DzInt -> Int
	Int "<=Int" Int -> Bool {left, cons("Bool125Syn")}
	Int "<Int" Int -> Bool {left, cons("Bool126Syn")}
	Int ">=Int" Int -> Bool {left, cons("Bool127Syn")}
	Int ">Int" Int -> Bool {left, cons("Bool128Syn")}
	Int "==Int" Int -> Bool {left, cons("Bool129Syn")}
	Int "=/=Int" Int -> Bool {left, cons("Bool130Syn")}
	"dummyNat" -> Nat {cons("Nat132Syn")}
	"isNat" "(" Int ")" -> Bool {cons("Bool133Syn")}
	Int "dividesInt" Int -> Bool {cons("Bool134Syn")}
	DzFloat -> Float
	"Int2Float" "(" Int ")" -> Float {cons("Float147Syn")}
	"Float2Int" "(" Float ")" -> Int {cons("Int148Syn")}
	DzId -> Id
	DzString -> String
	String "+String" String -> String {left, cons("String149Syn")}
	String "==String" String -> Bool {left, cons("Bool150Syn")}
	"lengthString" "(" String ")" -> Int {cons("Int152Syn")}
	"charString" "(" Int ")" -> String {cons("String153Syn")}
	"asciiString" "(" String ")" -> Int {cons("Int154Syn")}
	"substrString" "(" String "," Int "," Int ")" -> String {cons("String155Syn")}
	"Float2String" "(" Float ")" -> String {cons("String156Syn")}
	"String2Float" "(" String ")" -> Float {cons("Float157Syn")}
	"String2Int" "(" String ")" -> Int {cons("Int158Syn")}
	"Int2String" "(" Int ")" -> String {cons("String159Syn")}
	"Id2String" "(" Id ")" -> String {cons("String160Syn")}
	"String2Id" "(" String ")" -> Id {cons("Id162Syn")}
	String "=/=String" String -> Bool {left, cons("Bool163Syn")}
	"dummyChar" -> Char {cons("Char164Syn")}
	"isChar" "(" String ")" -> Bool {cons("Bool165Syn")}
	"#isWhiteSpace" "(" Char ")" -> Bool {cons("Bool166Syn")}
	"#isDigit" "(" Char ")" -> Bool {cons("Bool167Syn")}
	"#if" Bool "#then" K "#else" K "#fi" -> K {cons("K169Syn")}
	Set "<=Set" Set -> Bool {cons("Bool170Syn")}
	Set "==Set" Set -> Bool {cons("Bool172Syn")}
	Set "=/=Set" Set -> Bool {cons("Bool173Syn")}
	Map "<=Map" Map -> Bool {cons("Bool174Syn")}
	Map "==Map" Map -> Bool {cons("Bool175Syn")}
	Map "=/=Map" Map -> Bool {cons("Bool176Syn")}
	ListDlKDr "==List{K}" ListDlKDr -> Bool {cons("Bool177Syn")}
	ListDlKDr "=/=List{K}" ListDlKDr -> Bool {cons("Bool178Syn")}
	KLabel "==KLabel" KLabel -> Bool {cons("Bool179Syn")}
	"#EOF" -> TCPAnswer {cons("TCPAnswer180Syn")}
	String -> TCPAnswer
	"#tcpError" "(" String ")" -> TCPAnswer {cons("TCPAnswer182Syn")}
	"#tcpRequest" "(" String ")" -> TCPAnswer {cons("TCPAnswer183Syn")}
	"#checkTCPAnswer" "(" String ")" -> TCPAnswer {cons("TCPAnswer184Syn")}
	"##tcpRequest" "(" String ")" -> String {cons("String185Syn")}
	"#retrieveTCPError" "(" String ")" -> String {cons("String186Syn")}
	"#isTCPError" "(" String ")" -> Bool {cons("Bool187Syn")}
	"randomRandom" "(" Int ")" -> Int {cons("Int188Syn")}
	DzLTLFormula -> LTLFormula
	"LTL~" LTLFormula -> LTLFormula {cons("LTLFormula189Syn")}
	LTLFormula "LTL/\\" LTLFormula -> LTLFormula {cons("LTLFormula190Syn")}
	LTLFormula "LTL\\/" LTLFormula -> LTLFormula {cons("LTLFormula192Syn")}
	"LTLO" LTLFormula -> LTLFormula {cons("LTLFormula193Syn")}
	LTLFormula "LTLU" LTLFormula -> LTLFormula {cons("LTLFormula194Syn")}
	LTLFormula "LTLR" LTLFormula -> LTLFormula {cons("LTLFormula195Syn")}
	LTLFormula "LTL->" LTLFormula -> LTLFormula {cons("LTLFormula196Syn")}
	LTLFormula "LTL<->" LTLFormula -> LTLFormula {cons("LTLFormula197Syn")}
	"LTL<>" LTLFormula -> LTLFormula {cons("LTLFormula198Syn")}
	"LTL[]" LTLFormula -> LTLFormula {cons("LTLFormula199Syn")}
	LTLFormula "LTLW" LTLFormula -> LTLFormula {cons("LTLFormula1200Syn")}
	LTLFormula "LTL|->" LTLFormula -> LTLFormula {cons("LTLFormula1202Syn")}
	LTLFormula "LTL=>" LTLFormula -> LTLFormula {cons("LTLFormula1203Syn")}
	LTLFormula "LTL<=>" LTLFormula -> LTLFormula {cons("LTLFormula1204Syn")}
	DzModelCheckerState -> ModelCheckerState
	DzProp -> Prop
	DzModelCheckResult -> ModelCheckResult
	Prop -> LTLFormula
	"modelCheck" "(" ModelCheckerState "," LTLFormula ")" -> ModelCheckResult {cons("ModelCheckResult1205Syn")}
	K "inList{K}" ListDlKDr -> Bool {cons("Bool1206Builtin")}
	Map "(" K ")" -> K {cons("K1207Builtin")}
	Map "[" Map "]" -> Map {cons("Map1208Builtin")}
	Map "[" ListDlKDr "/" ListDlKDr "]" -> Map {cons("Map1209Builtin")}
	Map "[" "undef" "/" ListDlKDr "]" -> Map {cons("Map1220Builtin")}
	Map "(" ListDlKDr ")" -> ListDlKDr {cons("ListDlKDr1222Builtin")}
	"keys" Map -> Set {cons("Set1223Builtin")}
	"$hasMapping" "(" Map "," K ")" -> DzBool {cons("DzBool1224Builtin")}
	"Set" ListDlKDr -> Set {cons("Set1225Builtin")}
	Set "-Set" Set -> Set {cons("Set1226Builtin")}
	K "in" Set -> Bool {cons("Bool1227Builtin")}
	SetItem "in" Set -> Bool {cons("Bool1228Builtin")}
	"Bag" ListDlKDr -> Bag {cons("Bag1229Builtin")}
	Bag "-Bag" Bag -> Bag {cons("Bag1230Builtin")}
	K "in" Bag -> Bool {cons("Bool1232Builtin")}
	BagItem "in" Bag -> Bool {cons("Bool1233Builtin")}
	"List" ListDlKDr -> List {cons("List1234Builtin")}
	"lengthList" List -> Int {cons("Int1235Builtin")}
	KResult -> K
	"wklabel" KLabel -> KLabel {cons("KLabel1236Builtin")}
	"wcelllabel" CellLabel -> KLabel {cons("KLabel1237Builtin")}
	"kList" String -> KLabel {cons("KLabel1238Builtin")}
	"wbag" Bag -> KLabel {cons("KLabel1239Builtin")}
	"wset" Set -> KLabel {cons("KLabel1240Builtin")}
	"wlist" List -> KLabel {cons("KLabel1242Builtin")}
	"wmap" Map -> KLabel {cons("KLabel1243Builtin")}
	"getKLabel" K -> KLabel {cons("KLabel1245Builtin")}
	DzModelCheckerState "LTL|=" DzProp -> DzBool {cons("DzBool1246Builtin")}
	String -> K
	Int -> K
	Float -> K
	"#open" "(" String ")" -> K {cons("K1247Syn")}
	"#reopen" "(" Int "," String ")" -> K {cons("K1248Syn")}
	"#close" "(" Int ")" -> K {cons("K1249Syn")}
	"#fEof" "(" Int ")" -> K {cons("K1250Syn")}
	"#tell" "(" Int ")" -> K {cons("K1252Syn")}
	"#seek" "(" Int "," Int ")" -> K {cons("K1253Syn")}
	"#fPeekByte" "(" Int ")" -> K {cons("K1254Syn")}
	"String2Bool" "(" String ")" -> K {cons("K1255Syn")}
	"#ioError" "(" String ")" -> K {cons("K1256Syn")}
	"#fPutByte" "(" Int "," Int ")" -> K {cons("K1257Syn")}
	"#flush" "(" Int ")" -> K {cons("K1258Syn")}
	"#fReadByte" "(" Int ")" -> K {cons("K1259Syn")}
	"String2DotK" "(" String ")" -> K {cons("K1260Syn")}
	"#stdin" -> Int {cons("Int1262Syn")}
	"#stdout" -> Int {cons("Int1263Syn")}
	"#stderr" -> Int {cons("Int1264Syn")}
	"#readByte" "(" ")" -> K {cons("K1265Syn")}
	"#peekByte" "(" ")" -> K {cons("K1266Syn")}
	"#putByte" "(" Int ")" -> K {cons("K1267Syn")}
	"#eof" "(" ")" -> K {cons("K1268Syn")}
	"#string2Int" "(" K ")" -> K {cons("K1269Syn")}
	"#readChar" "(" ")" -> K {cons("K1270Syn")}
	"#fReadChar" "(" Int ")" -> K {cons("K1272Syn")}
	"#charString" "(" K ")" -> K {cons("K1273Syn")}
	"#printChar" "(" K ")" -> K {cons("K1274Syn")}
	"#fPrintChar" "(" Int "," K ")" -> K {cons("K1275Syn")}
	"#removeCharUponAck" -> List {cons("List1276Syn")}
	"#parse" "(" String "," K ")" -> List {cons("List1277Syn")}
	"#convertToken" "(" String "," String ")" -> List {cons("List1278Syn")}
	"#buffer" "(" K ")" -> List {cons("List1279Syn")}
	"#istream" "(" Int ")" -> List {cons("List1280Syn")}
	"#ostream" "(" Int ")" -> List {cons("List1282Syn")}
	"#noIO" -> List {cons("List1283Syn")}
	"main" -> Id {cons("Id1284Syn")}
	"int" -> Type {cons("Type1285Syn")}
	"bool" -> Type {cons("Type1286Syn")}
	"string" -> Type {cons("Type1287Syn")}
	"void" -> Type {cons("Type1288Syn")}
	"arrayOf" Type -> Type {cons("Type1289Syn")}
	"function" "from" Types "to" Type -> Type {cons("Type1290Syn")}
	Type -> Types
	".Types" -> Types {cons("Types1Empty")}
	Types "," Types -> Types {right, cons("Types1ListSyn")}
	"var" Exps ";" -> Ddecl {cons("Ddecl1292Syn")}
	Int -> Exp
	Bool -> Exp
	String -> Exp
	Id -> Exp
	"this" -> Exp {cons("Exp1293Syn")}
	"super" -> Exp {cons("Exp1294Syn")}
	"new" Id "(" Exps ")" -> Exp {cons("Exp1298Syn")}
	"sizeOf" "(" Exp ")" -> Exp {cons("Exp1304Syn")}
	"read" "(" ")" -> Exp {cons("Exp1305Syn")}
	Exp -> Exps
	".Exps" -> Exps {cons("Exps1Empty")}
	Exps "," Exps -> Exps {right, cons("Exps1ListSyn")}
	"{" "}" -> Stmt {cons("Stmt1334Syn")}
	"{" Stmts "}" -> Stmt {cons("Stmt1335Syn")}
	"return" Exp ";" -> Stmt {cons("Stmt1342Syn")}
	"return" ";" -> Stmt {cons("Stmt1343Syn")}
	"print" "(" Exps ")" ";" -> Stmt {cons("Stmt1344Syn")}
	"throw" Exp ";" -> Stmt {cons("Stmt1345Syn")}
	"acquire" Exp ";" -> Stmt {cons("Stmt1347Syn")}
	"release" Exp ";" -> Stmt {cons("Stmt1348Syn")}
	"rendezvous" Exp ";" -> Stmt {cons("Stmt1349Syn")}
	Exp ";" -> Stmt {cons("Stmt1336Syn")}
	"if" Exp "then" Stmt "else" Stmt -> Stmt {avoid, cons("Stmt1337Syn")}
	"if" Exp "then" Stmt -> Stmt {cons("Stmt1338Syn")}
	"while" Exp "do" Stmt -> Stmt {cons("Stmt1339Syn")}
	"for" Id "=" Exp "to" Exp "do" Stmt -> Stmt {cons("Stmt1340Syn")}
	"spawn" Stmt -> Stmt {cons("Stmt1346Syn")}
	Ddecl -> Stmts
	Stmt -> Stmts
	Stmts Stmts -> Stmts {right, cons("Stmts1350Syn")}
	"object" -> Id {cons("Id1352Syn")}
	"class" Id -> Type {cons("Type1353Syn")}
	"method" Id "(" Exps ")" DouaPuncteDz Type Stmt -> Ddecl {cons("Ddecl1354Syn")}
	"method" Id "(" Exps ")" Stmt -> Ddecl {cons("Ddecl1355Syn")}
	"class" Id "{" Stmts "}" -> Ddecl {cons("Ddecl1356Syn")}
	"class" Id "extends" Id "{" Stmts "}" -> Ddecl {cons("Ddecl1357Syn")}
	"try" Stmt "catch" "(" Exp ")" Stmt -> Stmt {cons("Stmt1358Syn")}
	Int -> Val
	Bool -> Val
	String -> Val
	"arrayRef" "(" Type "," Int "," Int ")" -> Val {cons("Val1359Syn")}
	Val -> Vals
	".Vals" -> Vals {cons("Vals1Empty")}
	Vals "," Vals -> Vals {right, cons("Vals1ListSyn")}
	Val -> Exp
	Val -> KResult
	"undefined" "(" Type ")" -> K {cons("K1360Syn")}
	"$1" -> Id {cons("Id1362Syn")}
	"$2" -> Id {cons("Id1363Syn")}
	"nothing" -> Val {cons("Val1364Syn")}
	"lvalue" "(" K ")" -> Exp {cons("Exp1365Syn")}
	"loc" "(" Nat ")" -> Val {cons("Val1366Syn")}
	"lookup" "(" Nat ")" -> K {cons("K1367Syn")}
	"env" "(" Map ")" -> K {cons("K1368Syn")}
	"typeOf" "(" K ")" -> Type {cons("Type1369Syn")}
	"types" "(" Exps ")" -> Types {cons("Types1370Syn")}
	Int ".." Int -> ListDlKDr {cons("ListDlKDr1372Syn")}
	"(" Exp "," Stmt "," K "," Map "," Bag ")" -> ListItem {cons("ListItem1373Syn")}
	"popx" -> K {cons("K1374Syn")}
	"bindto" "(" Exps "," Vals ")" -> K {cons("K1375Syn")}
	"objectClosure" "(" Bag ")" -> Val {cons("Val1376Syn")}
	"methodClosure" "(" Id "," Nat "," Exps "," Stmt "," Type ")" -> Val {cons("Val1377Syn")}
	"execute" -> K {cons("K1378Syn")}
	"create" "(" K ")" -> K {cons("K1379Syn")}
	"setCrntClass" "(" Id ")" -> K {cons("K1380Syn")}
	"addEnvLayer" -> K {cons("K1382Syn")}
	"storeObj" -> K {cons("K1383Syn")}
	"(" Map "," K "," Bag ")" -> K {cons("K1384Syn")}
	Id "::" Bag -> K {cons("K1385Syn")}
	"lookupMember" "(" BagItem "," Id ")" -> K {cons("K1386Syn")}
	"subtype" "(" Types "," Types ")" -> Exp {cons("Exp1387Syn")}
	"unsafeCast" "(" Val "," Type ")" -> Val {cons("Val1388Syn")}
	"true?" -> K {cons("K1389Syn")}
	Exp -> InsertDzExp
	Exps -> InsertDzExps


	VARID  ":" "Types"        -> VariableDz            {cons("Types12Var")}
	VARID  ":" "Bool"        -> VariableDz            {cons("Bool12Var")}
	VARID  ":" "Decl"        -> VariableDz            {cons("Ddecl12Var")}
	VARID  ":" "Type"        -> VariableDz            {cons("Type12Var")}
	VARID  ":" "#Id"        -> VariableDz            {cons("DzId12Var")}
	VARID  ":" "Stmts"        -> VariableDz            {cons("Stmts12Var")}
	VARID  ":" "ModelCheckResult"        -> VariableDz            {cons("ModelCheckResult12Var")}
	VARID  ":" "Vals"        -> VariableDz            {cons("Vals12Var")}
	VARID  ":" "KResult"        -> VariableDz            {cons("KResult12Var")}
	VARID  ":" "#Float"        -> VariableDz            {cons("DzFloat12Var")}
	VARID  ":" "TCPAnswer"        -> VariableDz            {cons("TCPAnswer12Var")}
	VARID  ":" "#String"        -> VariableDz            {cons("DzString12Var")}
	VARID  ":" "Exp"        -> VariableDz            {cons("Exp12Var")}
	VARID  ":" "#Int"        -> VariableDz            {cons("DzInt12Var")}
	VARID  ":" "Prop"        -> VariableDz            {cons("Prop12Var")}
	VARID  ":" "#ModelCheckerState"        -> VariableDz            {cons("DzModelCheckerState12Var")}
	VARID  ":" "#LTLFormula"        -> VariableDz            {cons("DzLTLFormula12Var")}
	VARID  ":" "Int"        -> VariableDz            {cons("Int12Var")}
	VARID  ":" "#ModelCheckResult"        -> VariableDz            {cons("DzModelCheckResult12Var")}
	VARID  ":" "#Bool"        -> VariableDz            {cons("DzBool12Var")}
	VARID  ":" "Exps"        -> VariableDz            {cons("Exps12Var")}
	VARID  ":" "#Prop"        -> VariableDz            {cons("DzProp12Var")}
	VARID  ":" "ModelCheckerState"        -> VariableDz            {cons("ModelCheckerState12Var")}
	VARID  ":" "Float"        -> VariableDz            {cons("Float12Var")}
	VARID  ":" "Nat"        -> VariableDz            {cons("Nat12Var")}
	VARID  ":" "Char"        -> VariableDz            {cons("Char12Var")}
	VARID  ":" "LTLFormula"        -> VariableDz            {cons("LTLFormula12Var")}
	VARID  ":" "String"        -> VariableDz            {cons("String12Var")}
	VARID  ":" "Stmt"        -> VariableDz            {cons("Stmt12Var")}
	VARID  ":" "Val"        -> VariableDz            {cons("Val12Var")}
	VARID  ":" "Id"        -> VariableDz            {cons("Id12Var")}

	"HOLE" ":" "Types"      -> VariableDz            {cons("Types12Hole")}
	"HOLE" ":" "Bool"      -> VariableDz            {cons("Bool12Hole")}
	"HOLE" ":" "Decl"      -> VariableDz            {cons("Ddecl12Hole")}
	"HOLE" ":" "Type"      -> VariableDz            {cons("Type12Hole")}
	"HOLE" ":" "#Id"      -> VariableDz            {cons("DzId12Hole")}
	"HOLE" ":" "Stmts"      -> VariableDz            {cons("Stmts12Hole")}
	"HOLE" ":" "ModelCheckResult"      -> VariableDz            {cons("ModelCheckResult12Hole")}
	"HOLE" ":" "Vals"      -> VariableDz            {cons("Vals12Hole")}
	"HOLE" ":" "KResult"      -> VariableDz            {cons("KResult12Hole")}
	"HOLE" ":" "#Float"      -> VariableDz            {cons("DzFloat12Hole")}
	"HOLE" ":" "TCPAnswer"      -> VariableDz            {cons("TCPAnswer12Hole")}
	"HOLE" ":" "#String"      -> VariableDz            {cons("DzString12Hole")}
	"HOLE" ":" "Exp"      -> VariableDz            {cons("Exp12Hole")}
	"HOLE" ":" "#Int"      -> VariableDz            {cons("DzInt12Hole")}
	"HOLE" ":" "Prop"      -> VariableDz            {cons("Prop12Hole")}
	"HOLE" ":" "#ModelCheckerState"      -> VariableDz            {cons("DzModelCheckerState12Hole")}
	"HOLE" ":" "#LTLFormula"      -> VariableDz            {cons("DzLTLFormula12Hole")}
	"HOLE" ":" "Int"      -> VariableDz            {cons("Int12Hole")}
	"HOLE" ":" "#ModelCheckResult"      -> VariableDz            {cons("DzModelCheckResult12Hole")}
	"HOLE" ":" "#Bool"      -> VariableDz            {cons("DzBool12Hole")}
	"HOLE" ":" "Exps"      -> VariableDz            {cons("Exps12Hole")}
	"HOLE" ":" "#Prop"      -> VariableDz            {cons("DzProp12Hole")}
	"HOLE" ":" "ModelCheckerState"      -> VariableDz            {cons("ModelCheckerState12Hole")}
	"HOLE" ":" "Float"      -> VariableDz            {cons("Float12Hole")}
	"HOLE" ":" "Nat"      -> VariableDz            {cons("Nat12Hole")}
	"HOLE" ":" "Char"      -> VariableDz            {cons("Char12Hole")}
	"HOLE" ":" "LTLFormula"      -> VariableDz            {cons("LTLFormula12Hole")}
	"HOLE" ":" "String"      -> VariableDz            {cons("String12Hole")}
	"HOLE" ":" "Stmt"      -> VariableDz            {cons("Stmt12Hole")}
	"HOLE" ":" "Val"      -> VariableDz            {cons("Val12Hole")}
	"HOLE" ":" "Id"      -> VariableDz            {cons("Id12Hole")}

	VariableDz -> K


	DzDzInt		-> DzInt	{cons("DzInt1Const")}
	DzDzBool	-> DzBool	{cons("DzBool1Const")}
	DzDzId		-> DzId		{cons("DzId1Const")}
	DzDzString	-> DzString	{cons("DzString1Const")}

	DzDzINT		-> DzDzInt
	DzDzBOOL	-> DzDzBool
	DzDzSTRING	-> DzDzString
	":" -> DouaPuncteDz {cons("DouaPuncte")}

context-free restrictions
	VariableDz -/- ~[\:\;\(\)\<\>\~\n\r\t\,\ \[\]\=\+\-\*\/\|\{\}\.]
	DouaPuncteDz -/- [A-Z]

lexical syntax
	"wrap-with" -> DzKLabel



%% terminals reject
	"Float2Int" -> VARID {reject}
	"String2DotK" -> VARID {reject}
	"Set" -> VARID {reject}
	"String2Int" -> VARID {reject}
	"Int2String" -> VARID {reject}
	"String2Float" -> VARID {reject}
	"List" -> VARID {reject}
	"String2Bool" -> VARID {reject}
	"String2Id" -> VARID {reject}
	"Float2String" -> VARID {reject}
	"Id2String" -> VARID {reject}
	"LTLO" -> VARID {reject}
	"LTLR" -> VARID {reject}
	"Int2Float" -> VARID {reject}
	"LTLW" -> VARID {reject}
	"LTLU" -> VARID {reject}
	"Bag" -> VARID {reject}

lexical restrictions
	%% follow restrictions
	"object" -/- [C].[l].[o].[s].[u].[r].[e]
	"-" -/- [I].[n].[t]
	"." -/- [T].[y].[p].[e].[s]
	"." -/- [E].[x].[p].[s]
	"or" -/- [B].[o].[o].[l]
	"+" -/- [S].[t].[r].[i].[n].[g]
	">=" -/- [F].[l].[o].[a].[t]
	"*" -/- [I].[n].[t]
	"-" -/- [S].[e].[t]
	"and" -/- [B].[o].[o].[l]
	"." -/- [V].[a].[l].[s]
	"==" -/- [M].[a].[p]
	"/" -/- [F].[l].[o].[a].[t]
	">=" -/- [I].[n].[t]
	"+" -/- [I].[n].[t]
	"-" -/- [F].[l].[o].[a].[t]
	"%" -/- [I].[n].[t]
	"<=" -/- [F].[l].[o].[a].[t]
	"==" -/- [I].[n].[t]
	"==" -/- [S].[t].[r].[i].[n].[g]
	"<=" -/- [S].[e].[t]
	"==" -/- [B].[o].[o].[l]
	"or" -/- [E].[l].[s].[e].[B].[o].[o].[l]
	">" -/- [F].[l].[o].[a].[t]
	"==" -/- [K]
	"and" -/- [T].[h].[e].[n].[B].[o].[o].[l]
	"lookup" -/- [M].[e].[m].[b].[e].[r]
	">" -/- [I].[n].[t]
	"==" -/- [F].[l].[o].[a].[t]
	"+" -/- [F].[l].[o].[a].[t]
	"%" -/- [F].[l].[o].[a].[t]
	"not" -/- [B].[o].[o].[l]
	"==" -/- [S].[e].[t]
	"<=" -/- [I].[n].[t]
	"/" -/- [I].[n].[t]
	"<=" -/- [M].[a].[p]
	"<" -/- [F].[l].[o].[a].[t]
	"-" -/- [B].[a].[g]
	"==" -/- [K].[L].[a].[b].[e].[l]
	"==K" -/- [L].[a].[b].[e].[l]
	"*" -/- [F].[l].[o].[a].[t]
	"<" -/- [I].[n].[t]
	"method" -/- [C].[l].[o].[s].[u].[r].[e]
lexical restrictions
%% some restrictions to ensure greedy matching for user defined constants
	DzDzId  -/- [a-zA-Z0-9]
	DzDzInt -/- [0-9]

