require "builtins/builtins.k"

interface K-TECHNIQUE
	// all in SDF directly
endinterface

module K-LISTK-EXTRAS
  imports K-TECHNIQUE
  
  syntax Bool ::= K "inList{K}" List{K} [function]
  syntax Bool ::= K "#inList{K}" List{K} [function] 
  rule K inList{K} L:List{K} => K #inList{K} L ==K true 
    [structural, anywhere]
  rule K #inList{K} (_,,K:K,,_) => true 
    [structural, anywhere]
endmodule

module K-MAP-EXTRAS
	imports K-TECHNIQUE
        imports K-SET-EXTRAS
	//imports BOOL

  syntax K ::= Map "(" K ")"  [function]
  rule (_ K1:K |-> K2:K)(K1) => K2 [structural, anywhere]

  syntax Map ::= Map "[" "undef" "/" List{K} "]"  [function]

  syntax Map ::= "Map" "(" List{K} "|->" List{K} ")"   [function]
  rule Map((K1:K => .List{K}),,_ |-> (K2:K => .List{K}),,_:K,,_) (. => K1 |-> K2)
  rule Map((K1:K => .List{K}),,_ |-> K2:K) (. => K1 |-> K2)
  rule Map(.List{K} |-> _) => .

  syntax Map ::= Map "[" List{K} "/" List{K} "]"  [function]
  rule (M:Map => M[K2/K1][K2'/K1'])[(K2:K,,K2':K => .List{K}),,_ 
                        /  (K1:K,,K1':K => .List{K}),,_]

  rule (M:Map K1:K |-> K2:K)[K2':K / K1] => M K1 |-> K2' 
    [structural, anywhere]
  rule M:Map[K2:K / K1:K] => M K1 |-> K2 
    when notBool(K1 in keys(M)) [structural, anywhere]
  
  rule M:Map[undef/ K,,Kl:List{K}] => M[undef/ K][undef/ Kl] when Kl =/=List{K} .List{K} [structural, anywhere]
  rule M:Map[undef/ .List{K}] => M [structural, anywhere]
  rule (M:Map K |-> _)[undef/ K] => M [structural, anywhere]

  syntax Map ::= Map "[" Map "]"   [function, cons(Map1UpdateMapWithMapSyn)]
  rule M:Map[M':Map K1 |-> K2] => M[K2/K1][M'] [structural]
  rule M:Map[.Map] => M [structural]

//  syntax List{K} ::= Map "(" List{K} ")"
//  rule Map:Map((K1:K,,K2:K,,Ks:List{K})) 
//    => Map(K1),,Map(K2),,Map(Ks) [structural]
//  rule Map:Map(.List{K}) => .List{K} [structural]

	syntax Set ::= "keys" Map  [function]

  rule keys . => .
  rule (keys ((K:K |->_  => .) _)) (. => SetItem(K))

  syntax Bool ::= "$hasMapping" "(" Map "," K ")" [function,maudeop("$hasMapping")]
  syntax Bool ::= "#hasMapping" "(" Map "," K ")" [function, maudeop("#hasMapping")]
  rule $hasMapping(M:Map,K:K) => #hasMapping(M,K) ==K true [structural, anywhere]

  rule #hasMapping(M:Map K:K |-> _,K) => true [structural, anywhere]
endmodule

module K-SET-EXTRAS
	imports K-TECHNIQUE

//	syntax Set ::= "Set" List{K}
        syntax Set ::= Set "-Set" Set  [function, latex({#1}-_{\it Set}{#2})]
  rule S1:Set -Set (SI1:SetItem SI2:SetItem S2:Set)
    => ((S1 -Set SI1) -Set SI2) -Set S2
  rule S1:Set -Set . => S1 
  rule (SI:SetItem S:Set) -Set SI => S
  rule S:Set -Set SI:SetItem => S when SI in S ==Bool false //  [owise]

	syntax Bool ::= K "in" Set   [function, klabel(inSet)]
			      | SetItem "in" Set   [function, klabel(kInSet)]	
			      | K "#inSet" Set   [function]	
   rule SetItem(K:K) in S:Set => K in S [structural, anywhere]
   rule K:K in S:Set => K #inSet S ==K true
     [structural, anywhere]
   rule K #inSet SetItem(K) S:Set => true
     [structural, anywhere]

   rule (SetItem(K:K) S1:Set) -Set (SetItem(K:K) S2:Set) => S1 -Set (SetItem(K:K) S2) [structural, anywhere]
   rule (SetItem(K:K) S1:Set) -Set S2:Set => SetItem(K:K) (S1 -Set S2) when notBool K in S2 [structural, anywhere]
   rule .Set -Set S:Set => .Set [structural, snywhere]

endmodule

interface K-BAG-EXTRAS
	imports K-TECHNIQUE
	//imports IF-THEN-ELSE

//	syntax Bag ::= "Bag" List{K}
//				 | Bag "-Bag" Bag
//	syntax Bool ::= K "in" Bag
//				  | BagItem "in" Bag
endinterface

interface K-LIST-EXTRAS
	imports K-TECHNIQUE
	//imports BOOL

//	syntax List ::= "List" List{K}

	syntax Int ::= "lengthList" List [function]

   rule lengthList ( ListItem(K:K) L:List ) => 1 +Int lengthList L [structural, anywhere]
   rule lengthList .List => 0 [structural, anywhere]
endinterface

interface K-RESULT
	imports K-TECHNIQUE

	syntax K ::= KResult

	//op .List{K} : -> List{KResult} [ditto metadata "latex=(renameTo \\ensuremath{\\dotCt{List\\{K\\}}})"] .

endinterface

interface K-WRAPPERS-LABELS
	imports K-TECHNIQUE

	syntax KLabel ::= "KLabel2KLabel" KLabel
					| "CellLabel2KLabel" CellLabel
					| "List{K}2KLabel" String
					| "Bag2KLabel" Bag
					| "Set2KLabel" Set
					| "List2KLabel" List
					| "Map2KLabel" Map
					| "wrap-with"

endinterface

module K-DESTRUCTORS
	syntax KLabel ::= "getKLabel" K
  rule getKLabel(L:KLabel(_:List{K})) => L [structural, anywhere]

endmodule

interface K-WRAPPERS
	imports K-TECHNIQUE

	syntax K ::= "KLabel2K" KLabel
			   | "Celllabel2K" CellLabel
			   | "List{K}2K" List{K}
			   | "Set2K" Set
			   | "Bag2K" Bag
			   | "List2K" List
			   | "Map2K" Map
endinterface

interface K-EVAL
  imports K-TECHNIQUE
  syntax Bag ::= "#eval" Map          [cons(Bag1EvalSyn)]
  syntax Bag ::= "#evalHelper" Map    [cons(Bag1EvalHelperSyn)]
endinterface

module K-BUILTINS
  syntax KLabel ::=  "#" K
endmodule


interface K-FRESH
  imports K-TECHNIQUE
  syntax Bool ::= "fresh" "(" K ")"  [cons(Bool1FreshSyn)]
endinterface

interface K-COOL
  imports K-TECHNIQUE
  syntax KLabel ::= "cool"
endinterface

interface K
  imports K-TECHNIQUE
  imports K-WRAPPERS
  imports K-WRAPPERS-LABELS
  imports K-BUILTINS
  imports K-RESULT             // to express results syntactically
  imports K-RULES              // to write k rules with in-place rewriting
  imports K-CONFIG             // to specify the global configuration term
  imports K-EVAL
  imports K-POLYMORPHIC-VARIABLES // defines the ? polmorfic constant
  imports K-OPEN-CELLS            // defines open cells like <_>..._...</_> 
  imports K-CONTEXTS  
  imports K-DESTRUCTORS           // defines getKLabel and getList{K} for K
  //imports K-EXTRAS                // defines a KLabel substitution 
  imports K-COOL
  imports K-LISTK-EXTRAS  
  imports K-LIST-EXTRAS  
  imports K-MAP-EXTRAS            // operations on Maps
  imports K-BAG-EXTRAS            // operations on Bags
  imports K-SET-EXTRAS            // operations on Sets
  //imports K-LATEX  
endinterface

