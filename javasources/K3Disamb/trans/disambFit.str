module disambFit

imports
	libstratego-lib
	libstratego-gpp
	libstratego-aterm
	libstratego-sglr

	include/K3Disamb

	disambSup
	starter
	disambCells

strategies

	chooseBestFitRec =
		 bottomup(try(chooseBestFit))

	chooseBestFit:
		amb(x) -> rez2
		where rez := <filterSize> x
		where rez2 := <if <lt>(<length> rez, 2) then  !<last> rez else !amb(rez) end>

	filterSize:
		xs -> xs2
		where mymax := <foldr(!-2147483600, max)> (<all(getFitness)> xs)		// calculate the size of the smallest term
		where xs2 := <filter(findLargest(|mymax))> xs							// filter terms that are of a greater size

	findLargest(|size) =
		where(currSize := <getFitness> ;
		<eq>(currSize, size))

	getFitness:
		x#(xs) -> score
		where <one(?(x, sort, terms))>  <MemoMyCons>
		where score := <foldr(!0, add)> (<zip(getFitnessUnit)> (terms, xs))

	getFitnessUnit:
		(a, b#(_)) -> score
		where !b => "amb"
		where score := 0

	getFitnessUnit:
		(a, b#(_)) -> score									// match on a pair made by ziping terms with the current terms
		where not(!b => "amb")
		where b' := <getSort> b
		where score := 	<(	isSubsortEq(|"K", a) ; (<?"K"> b' <+ <?"K"> a); !0 <+ // if the sort is K then score it as 0, only if the expected sort is a subsort of K
							isSubsortEq(|a, b') ; !1 <+		// if the sort is a subsort then put 1
							!-1								// if none of the above, then put -1
						)>

	// ------------- new type filter that goes deeper
	getFitness2(|expect):
		a#(_) -> 0
		where <string-ends-with(|"Var") <+
		       string-ends-with(|"Const") <+
		       string-ends-with(|"Empty") <+
		       string-ends-with(|"Hole")> a

	getFitness2(|expect):
		[] -> 0

	getFitness2(|expect):
		a#([x, y]) -> <add> (score1, score2)
		where <string-ends-with(|"Rewrite") <+
		       string-ends-with(|"List") <+
		       string-ends-with(|"K1Seq")> a
		where score1 := <getFitness2(|<getSort> a)> x
		where score2 := <getFitness2(|<getSort> a)> y

	getFitness2(|expect):
		a#([x]) -> score
		where <string-ends-with(|"Item")> a
		where score := <getFitness2(|"K")> x

	getFitness2(|expect):
		MapItem1LKLKItem(x, y) -> <add> (score1, score2)
		where score1 := <getFitness2(|"List{K}")> x
		where score2 := <getFitness2(|"List{K}")> y

	getFitness2(|expect):
		Bag1ClosedCell(x1, x2, x3, x4) -> score
		where MemoMyCells ; one(?(x1, expected2))
		where score := <getFitness2(|expected2)> x3

	getFitness2(|expect):
		K1App(a, b) -> <add> (score1, score2)
		where score1 := <getFitness2(|"KLabel")> a
		where score2 := <getFitness2(|"List{K}")> b


	getFitnessUnit2:
		(expect, place) -> score
		where score :=  <(	isSubsortEq(|expect, place) ; !0 <+		// if the sort is a subsort then put 1
							isSubsortEq(|"K", expect) ; (<?"K"> place <+ <?"K"> expect); !0 <+ // if the sort is K then score it as 0, only if the expected sort is a subsort of K
							!-1								// if none of the above, then put -1
						)>










 