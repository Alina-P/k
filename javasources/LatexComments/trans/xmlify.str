module xmlify

imports
  libstratego-lib
  libstratego-sglr
  include/LatexComments

rules

	//test1 = !"KSyntax.tbl" ; file-exists
	//test3 = dummy(|<import-term(KSyntax.tbl)>) ; !1
	//dummy(|a) = debug(!"Rez here: ")

	//test4 = <find-file(!"tbl")> ("KSyntax.tbl", ["."])
	//test5 = <parse-file-pt(|<import-term(KSyntax.tbl)>)> "example.k"
	//test6 = import-term(Simple.sbs) ; debug(!"Sorts: ")
	//test7 = <parse-string(|<import-term(KSyntax.tbl)>)> "kmod A is\n rule a endkm" ; prim("SSL_EXT_origin_location", <id>)
	//test8 = import-term(Simple.sbs) ; topdown(debug(!"Term: "))
	//test9 = import-term(Simple.sbs) ; debug(!"Terms1") ; implode-asfix ; debug(!"Terms2") 
	//test10 = parse-file-pt(|<import-term(KSyntax.tbl)>, None(), Stream(<prim("SSL_stdin_stream")> ()))
	//test11 = <read-text-file> stdin() //"/Users/radu/Desktop/work2/workspacespoofax/KJava/src/example.k"
	//test12 = parse-xtc-file(|<import-term(KSyntax.tbl)>, None(), "stdin")
	//test13 = <memo-openre-parse-table> include/KSyntax.tbl



	// the editor will call this:
	callxml = callxml1 <+ callxml2 <+ to-xml

	callxml1:
		(selected, position, ast, path, project-path) -> (filename, result)
	with
		filename := <guarantee-extension(|"xml")> path;
		result   := <callxml> selected
	callxml2:
		(ast, path, project-path) -> <to-xml> ast


	prim-origin-offset = prim("SSL_EXT_origin_offset", <id>)

	// command line will call this:
	// compile like this: java -jar strategoxt.jar -i xmlify.str -o a.out -la stratego-sglr -I .. -m safecallcmd1
	// this will generate a .java file called a.java - put this in a eclipse Java project and export a jar file
	// run like this: java -jar ksyntax.jar d:\work\strategoxt\example.k
	// generate a lib like this: java -jar strategoxt.jar -i xmlify.str -o K2Str -la stratego-sglr --lib -I .. -p k2parser.lib --clean
	// this will generate a bunch of files in K2Str, copy these in a java package and call something like Context.init()

	//callcmd1 = ?[a, b] ; <parse-file(|<import-term(include/KSyntax.tbl)>)> b ; to-xml
	//callcmd2 = ?[a, b] ; <parse-file(|<import-term(include/KSyntax.tbl)>)> b ; debug ; clearamb ; debug ; to-xml

	//safecallcmd1 = ?[a, b] ; <parse-file(my-open-error, my-parse-error|<import-term(include/KSyntax.tbl)>)> b ; to-xml

	javaParseString = ?[a, b] ; <parse-string(my-parse-error|<import-term(include/LatexComments.tbl)>)> b ; processParse

	processParse =
		(handleErrors <+ to-xml)

	handleErrors =
		(?error(_,_) ; (to-xml-error <+ debug(!"Error: This should not happen. Please report.")))


	to-xml-error:
		error(a, b*) -> $[<?xml version="1.0" encoding="UTF-8" ?>
		<T>
			<error value="[<xmlStringEscapeToString>a]">
				[b']
			</error>
		</T>
		]
		where b' := <all(to-xml-error)> b*

	to-xml-error:
		localized(a, b) ->
			$[<localized message="[<xmlStringEscape>a]" filename="[<xmlStringEscape>x]" loc="[loc]" />
			]
		where (!b => (x, area(y1, y2, y3, y4, y5, y6))) <+ (!b => area-in-file(x, area(y1, y2, y3, y4, y5, y6)))
		where loc := <write-to-string> (y1, y2, y3, y4)

	to-xml-error-open:
		[a, b] -> $[<?xml version="1.0" encoding="UTF-8" ?>
		<error value="Open error">
			<file value="[<xmlStringEscape>b]" />
		</error>
		]



	my-open-error = mydebug(!"OpenError: ")
	my-parse-error = mydebug(!"ParseError: ")

	mydebug = id//debug
	mydebug(a) = id//debug(a)
	// xmlify - starts from here
	xmlStringEscape         = string-replace(|"&", "&amp;") ;
	                          string-replace(|">", "&gt;") ;
	                          string-replace(|"<", "&lt;") ; 
	                          string-replace(|"\"", "&quot;") ;
	                          string-replace(|"\\", "\\\\") ;
	                          string-replace(|"\n", "\\n") ;
	                          string-replace(|"\r", "\\r")
	                          
	xmlStringEscapeToString = string-replace(|"&", "&amp;") ; string-replace(|">", "&gt;") ; string-replace(|"<", "&lt;") ; string-replace(|"\\\"", "&quot;")
	getLocAsString        = prim("SSL_EXT_origin_location", <id>) ; write-to-string
	get-original-sentence = prim("SSL_EXT_origin_text", <id>) ; xmlStringEscape ; escape


	// print the K definition as an XML - parsing only the syntax
	to-xml:
		Comments(x*) -> $[<?xml version="1.0" encoding="UTF-8" ?>
			<def loc="[loc]">
				[x']
			</def>
			]
		where mydebug(!"Comments: ")
		where x' := <all(to-xml)> x*		// print to XML all the modules
		where loc := <getLocAsString>		// get the location info

	to-xml:
		Comment(x) -> $[<comment value="[<xmlStringEscape>x]" loc="[loc]"/>
		]
		where loc := <getLocAsString>		// get the location info


