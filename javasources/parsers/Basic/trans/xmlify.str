module xmlify

imports
  libstratego-lib
  libstratego-sglr
  include/Basic

rules

	//test1 = !"KSyntax.tbl" ; file-exists
	//test3 = dummy(|<import-term(KSyntax.tbl)>) ; !1
	//dummy(|a) = debug(!"Rez here: ")

	//test4 = <find-file(!"tbl")> ("KSyntax.tbl", ["."])
	//test5 = <parse-file-pt(|<import-term(KSyntax.tbl)>)> "example.k"
	//test6 = import-term(Simple.sbs) ; debug(!"Sorts: ")
	//test7 = <parse-string(|<import-term(KSyntax.tbl)>)> "kmod A is\n rule a endkm" ; prim("SSL_EXT_origin_location", <id>)
	//test8 = import-term(Simple.sbs) ; topdown(debug(!"Term: "))
	//test9 = import-term(Simple.sbs) ; debug(!"Terms1") ; implode-asfix ; debug(!"Terms2") 
	//test10 = parse-file-pt(|<import-term(KSyntax.tbl)>, None(), Stream(<prim("SSL_stdin_stream")> ()))
	//test11 = <read-text-file> stdin() //"/Users/radu/Desktop/work2/workspacespoofax/KJava/src/example.k"
	//test12 = parse-xtc-file(|<import-term(KSyntax.tbl)>, None(), "stdin")
	//test13 = <memo-openre-parse-table> include/KSyntax.tbl



	// the editor will call this:
	callxml = callxml1 <+ callxml2 <+ to-xml

	callxml1:
		(selected, position, ast, path, project-path) -> (filename, result)
	with
		filename := <guarantee-extension(|"xml")> path;
		result   := <callxml> selected
	callxml2:
		(ast, path, project-path) -> <to-xml> ast


	prim-origin-offset = prim("SSL_EXT_origin_offset", <id>)

	// command line will call this:
	// compile like this: java -jar strategoxt.jar -i xmlify.str -o a.out -la stratego-sglr -I .. -m safecallcmd1
	// this will generate a .java file called a.java - put this in a eclipse Java project and export a jar file
	// run like this: java -jar ksyntax.jar d:\work\strategoxt\example.k
	// generate a lib like this: java -jar strategoxt.jar -i xmlify.str -o K2Str -la stratego-sglr --lib -I .. -p k2parser.lib --clean
	// this will generate a bunch of files in K2Str, copy these in a java package and call something like Context.init()

	//callcmd1 = ?[a, b] ; <parse-file(|<import-term(include/KSyntax.tbl)>)> b ; to-xml
	//callcmd2 = ?[a, b] ; <parse-file(|<import-term(include/KSyntax.tbl)>)> b ; debug ; clearamb ; debug ; to-xml

	//safecallcmd1 = ?[a, b] ; <parse-file(my-open-error, my-parse-error|<import-term(include/KSyntax.tbl)>)> b ; to-xml

	javaParseString = ?[a, b] ; <parse-string(my-parse-error|<import-term(include/Basic.tbl)>)> b ; processParse

	processParse =
		(handleErrors <+ to-xml)

	handleErrors =
		(?error(_,_) ; (to-xml-error <+ debug(!"Error: This should not happen. Please report.")))


	to-xml-error:
		error(a, b*) -> $[<?xml version="1.0" encoding="UTF-8" ?>
		<T>
			<error value="[<xmlStringEscape>a]">
				[b']
			</error>
		</T>
		]
		where b' := <all(to-xml-error)> b*

	to-xml-error:
		localized(a, b) ->
			$[<localized message="[<xmlStringEscape>a]" filename="[<xmlStringEscape>x]" loc="[loc]" />
			]
		where (!b => (x, area(y1, y2, y3, y4, y5, y6))) <+ (!b => area-in-file(x, area(y1, y2, y3, y4, y5, y6)))
		where loc := <write-to-string> (y1, y2, y3, y4)

	to-xml-error-open:
		[a, b] -> $[<?xml version="1.0" encoding="UTF-8" ?>
		<error value="Open error">
			<file value="[<xmlStringEscape>b]" />
		</error>
		]



	my-open-error = mydebug(!"OpenError: ")
	my-parse-error = mydebug(!"ParseError: ")

	mydebug = id//debug
	mydebug(a) = id//debug(a)
	// xmlify - starts from here
	xmlStringEscape         = string-replace(|"&", "&amp;") ; string-replace(|">", "&gt;") ; string-replace(|"<", "&lt;") ; string-replace(|"\"", "&quot;")
	//xmlStringEscape           = string-replace(|"&", "&amp;") ; string-replace(|">", "&gt;") ; string-replace(|"<", "&lt;") ; string-replace(|"\\", "\\\\") ; string-replace(|"\"", "&quot;")
	//xmlStringEscapeFromString = string-replace(|"&", "&amp;") ; string-replace(|">", "&gt;") ; string-replace(|"<", "&lt;") ; string-replace(|"\\\"", "&quot;")
	getLocAsString        = prim("SSL_EXT_origin_location", <id>) ; ?(a, b, c, d) ; !(a, <add> (b, 1), c, <add> (d, 2)) ; write-to-string <+ !"(0,0,0,0)"
	//external myorigin(|)
	//getLocAsString        = myorigin ; write-to-string <+ !"(0,0,0,0)"
	get-original-sentence = prim("SSL_EXT_origin_text", <id>) ; xmlStringEscape ; escape

	disamb = clear-console
	external clear-console(|)
	external xml-string-escape-from-string(|)
	external get-layout(|)

	// print the K definition as an XML - parsing only the syntax
	to-xml:
		KModuleList(i*, x*) -> $[<?xml version="1.0" encoding="UTF-8" ?>
			<def loc="[loc]">
				[i']
				[x']
				[lay]
			</def>
			]
		where mydebug(!"KModuleList: ")
		where i' := <all(to-xml)> i*
		where x' := <all(to-xml)> x*		// print to XML all the modules
		where loc := <getLocAsString>		// get the location info
		where lay := <get-layout ; all(to-xml)>

	to-xml:
		Require(x) -> $[<require value="[<xml-string-escape-from-string>x]" loc="[loc]"/>
		]
		where loc := <getLocAsString>	// get all of the production rules

	to-xml:
		KModule(x1, x2*, x3*) ->
			$[<module value="[x1]" loc="[loc]" type="module">
				[x2'*]
				[x3'*]
			</module>
			]
		where mydebug(!"KModule: ")
		where x2'* := <all(to-xml)> x2*		// transform all of the sentences in a module
		where x3'* := <all(to-xml)> x3*		// transform all of the sentences in a module
		where loc := <getLocAsString>	// get all of the production rules

	to-xml:
		KInterface(x1, x2*, x3*) ->
			$[<module value="[x1]" loc="[loc]" type="interface">
				[x2'*]
				[x3'*]
			</module>
			]
		where mydebug(!"KModule: ")
		where x2'* := <all(to-xml)> x2*		// transform all of the sentences in a module
		where x3'* := <all(to-xml)> x3*		// transform all of the sentences in a module
		where loc := <getLocAsString>	// get all of the production rules

	to-xml:
		Imports(x1) -> $[<import name="[x1]" loc="[locs]"/>
		]
		where locs := <getLocAsString> x1

	to-xml:
		Syntax(x1, x2*) -> $[<syntax loc="[loc]">
								<sort value="[x1]" loc="[locs]" />
								[x2'*]
			</syntax>
		]
		where mydebug(!"Syntax: ")
		where x2'* := <all(to-xml)> x2*	// get all of the production rules
		where loc := <getLocAsString>
		where locs := <getLocAsString> x1

	to-xml:
		OrList(a*) -> $[<priority loc="[loc]">
							[<all(to-xml)> a*]
			</priority>
		]
		where loc := <getLocAsString>

	to-xml:
		LeftOrList(a*) -> $[<priority loc="[loc]" assoc="left">
								[<all(to-xml)> a*]
			</priority>
		]
		where loc := <getLocAsString>

	to-xml:
		RightOrList(a*) -> $[<priority loc="[loc]" assoc="right">
								[<all(to-xml)> a*]
			</priority>
		]
		where loc := <getLocAsString>

	to-xml:
		NonAssocOrList(a*) -> $[<priority loc="[loc]" assoc="non-assoc">
							[<all(to-xml)> a*]
			</priority>
		]
		where loc := <getLocAsString>

	to-xml:
		Sort(x1)		-> $[<sort     value="[x1]" loc="[loc]" />
		]
		where loc := <getLocAsString>

	to-xml:
		List(x1, x2)		-> $[<userlist     value="[x1]" separator="[<xml-string-escape-from-string> x2]" loc="[loc]" />
		]
		where loc := <getLocAsString>

	to-xml:	// print an annotated production rule
		AnnoProd(a*, b*) -> $[<production loc="[loc]">
								[a'*]
								<attributes loc="[loc]">
									[b'*]
								</attributes>
						</production>
						]
		where mydebug(!"AnnoProd: ")
		where a'* := <all(to-xml)> a*
		where b'* := <all(to-xml)> b*
		where loc := <getLocAsString>

	to-xml:	// print an annotated production rule
		ShortAnnoProd(x, a*, b*) -> $[<production loc="[loc]">
										<terminal value="[x]" loc="[loc]" />
										<terminal value="(" loc="[loc]" />
										[a'*]
										<terminal value=")" loc="[loc]" />
										<attributes loc="[loc]">
											<tag key="klabel" value="'[x]" />
											[b'*]
										</attributes>
						</production>
						]
		where mydebug(!"ShortAnnoProd: ")
		where aa  := <all({z: \z -> Sort(z)\}) ; add-commas ; flatten-list> a*
		where a'* := <all(to-xml)> aa
		where b'* := <all(to-xml)> b*
		where loc := <getLocAsString>

	to-xml:	// print an annotated production rule
		TupleAnnoProd(a*, b*) -> $[<production loc="[loc]">
										<terminal value="(" loc="[loc]" />
										[a'*]
										<terminal value=")" loc="[loc]" />
										<attributes loc="[loc]">
											[b'*]
										</attributes>
						</production>
						]
		where mydebug(!"ShortAnnoProd: ")
		where aa  := <all({z: \z -> Sort(z)\}) ; add-commas ; flatten-list> a*
		where a'* := <all(to-xml)> aa
		where b'* := <all(to-xml)> b*
		where loc := <getLocAsString>

	to-xml:	// print a production rule
		Prod(a*) -> $[<production loc="[loc]">
						[a'*]
					</production>
					]
		where mydebug(!"Prod: ")
		where a'* := <all(to-xml)> a*
		where loc := <getLocAsString>

	to-xml:	// print a production rule
		ShortProd(x, a*) -> $[<production loc="[loc]">
								<terminal value="[x]" loc="[loc]" />
								<terminal value="(" loc="[loc]" />
								[a'*]
								<terminal value=")" loc="[loc]" />
								<attributes loc="[loc]">
									<tag key="klabel" value="'[x]" />
								</attributes>
					</production>
					]
		where mydebug(!"ShortProd: ")
		where aa  := <all({z: \z -> Sort(z)\}) ; add-commas ; flatten-list> a*
		where a'* := <all(to-xml)> aa
		where loc := <getLocAsString>

	to-xml:	// print a production rule
		TupleProd(a*) -> $[<production loc="[loc]">
								<terminal value="(" loc="[loc]" />
								[a'*]
								<terminal value=")" loc="[loc]" />
					</production>
					]
		where mydebug(!"ShortProd: ")
		where aa  := <all({z: \z -> Sort(z)\}) ; add-commas ; flatten-list> a*
		where a'* := <all(to-xml)> aa
		where loc := <getLocAsString>

	add-commas:
		[a] -> [a]
	add-commas:
		[hd | tl] -> [hd, Terminal("\",\"") | <add-commas> tl]


	to-xml:
		Terminal(s) -> $[<terminal value="[s']" loc="[loc]" />
		]
		where s' := <xml-string-escape-from-string> s
		where loc := <getLocAsString>

	to-xml:
		Config(x1) -> $[<config loc="[loc]" value="[x1']" />
		]
		where mydebug(!"Config: ")
		where x1' := <get-original-sentence>
		where loc := <getLocAsString>

	to-xml:
		Context(x1) -> $[<context loc="[loc]" value="[x1']" />
		]
		where mydebug(!"Context: ")
		where x1' := <get-original-sentence>
		where loc := <getLocAsString>

	to-xml:
		Rule(x1) -> $[<rule loc="[loc]" value="[x1']" />
		]
		where mydebug(!"Context: ")
		where x1' := <get-original-sentence>
		where loc := <getLocAsString>

	to-xml:
		Tag(x) -> $[<tag key="[x]" loc="[loc]" />
		]
		where loc := <getLocAsString>

	to-xml:
		TagParam(x, y) -> $[<tag key="[x]" value="[<xmlStringEscape> y]" loc="[loc]" />
		]
		where loc := <getLocAsString>

	to-xml:
		TagString(x, y) -> $[<tag key="[x]" value="[<xml-string-escape-from-string> y]" loc="[loc]" />
		]
		where loc := <getLocAsString>

	to-xml:
		"Comment"#([a, b]) -> $[<comment value="[<xmlStringEscape ; escape> a]" loc="[b]" />
		]


	to-xml:
		Priority(x) -> $[<prisent loc="[loc]">
							[x2'*]
			</prisent>
		]
		where mydebug(!"Priority: ")
		where x2'* := <all(to-xml)> x	// get all of the production rules
		where loc := <getLocAsString>
 
	to-xml:
		PriorityBlock(x) -> $[<priblock loc="[loc]">
								[x2'*]
			</priblock>
		]
		where mydebug(!"PriorityBlock: ")
		where x2'* := <all(to-xml)> x	// get all of the production rules
		where loc := <getLocAsString>

	to-xml:
		LeftPriorityBlock(x) -> $[<priblock loc="[loc]" assoc="left">
									[x2'*]
			</priblock>
		]
		where mydebug(!"PriorityBlock: ")
		where x2'* := <all(to-xml)> x	// get all of the production rules
		where loc := <getLocAsString>

	to-xml:
		RightPriorityBlock(x) -> $[<priblock loc="[loc]" assoc="right">
									[x2'*]
			</priblock>
		]
		where mydebug(!"PriorityBlock: ")
		where x2'* := <all(to-xml)> x	// get all of the production rules
		where loc := <getLocAsString>
		
	to-xml:
		NonAPriorityBlock(x) -> $[<priblock loc="[loc]" assoc="non-assoc">
									[x2'*]
			</priblock>
		]
		where mydebug(!"PriorityBlock: ")
		where x2'* := <all(to-xml)> x	// get all of the production rules
		where loc := <getLocAsString>

	to-xml:
		KLabel(x) -> $[<const sort="KLabel" value="[<xmlStringEscape ; escape> x]" loc="[loc]"/>
		]
		where loc := <getLocAsString>

