# Overview

K is an executable semantic framework in which programming languages,
calculi, as well as type systems or formal analysis tools can be
defined making use of configurations, computations and rules.

* *Configurations* organize the system/program state in units called cells,
which are labeled and can be nested.
* *Computations* carry "computational meaning" as special nested list
structures sequentializing computational tasks, such as fragments of
program; in particular, computations extend the original language or
calculus syntax.
* *K (rewrite) rules* generalize conventional rewrite rules by making it
explicit which parts of the term they read-only, write-only, or do not
care about. This distinction makes K a suitable framework for defining
truly concurrent languages or calculi even in the presence of sharing.

Since computations can be handled like any other terms in a rewriting
environment, that is, they can be matched, moved from one place to another
in the original term, modified, or even deleted, K is particularly suitable
for defining control-intensive language features such as abrupt termination,
exceptions, call/cc, concurrency, etc.

## The K Prototype

The k-framework.googlecode project, also called the "K prototype" from here on,
is a prototype implementation of the K Framework written in Maude and using
Maude to give a rewriting executable semantics to K definitions.

The K prototype is developed by a joint team of faculty and students from
University of Illinois at Urbana-Champaign (the FSL group, led by professor
Grigore Rosu), and University Alexandru Ioan Cuza, Iasi, Romania (the FMSE
group, led by professor Dorel Lucanu).

A current list of the people involved in the project and their specific roles
can be accessed at http://code.google.com/p/k-framework/people/list.


# Installation

For detailed installation instructions, please see the INSTALL file. 

As the tool is still under active development, it is recommended that you 
install K directly from the svn repository and update it regularly executing

  svn up && make

from the base directory to benefit of the latest fixes and features.


# Usage

The languages defined so far using the K framework can be found in the
examples directory. For example, the directory

 examples/languages/research/simple 

contains 2 directories, namely "untyped" containing the definition of the 
untyped version of the language, and "typed" which in turn contains three
directories with definitions: "static", for the static semantics, i.e.,
the type checker; "dynamic", for the dynamically typed version of simple;
and "dynamic-typed-locations" which is a variant of dynamic, in which the
type information is maintained in the environment.

We encourage you to contribute with examples to our distribution.
Please see examples/README for instructions on how to do it.

## When writing new definitions

It is recommended that the name of the main module of a definition
is the capitalized version of the name of the file containing it.

When adding new rules to a definition, keep in mind the following
important restrictions:
(1) avoid defining multiple constructs with the same name,
except for the case below;
(2) in rules, any construct should be applied on terms of
the syntactic types the construct was declared to accept (that is, no
subterm appearing in any rule should parse to a kind); if desired,
overload the operations to extend their range.

To compile a definition: execute the `kompile` script passing as parameter
the name of the file containing the main module.  If the compilation succeeds,
the output would be placed in name-of-the-file-compiled.maude. Currently, the
script has only been tested on Unix-like systems, including MacOSX.

Recommendations on running the script:
* The Maude executable should be on the path and should be named `maude`;
moreover, the environment variable `MAUDE_LIB` should point to the location
where `prelude.maude` resides
* The `kompile` script should also be on the path
* The `kompile` script should not be moved from the `core` directory
* The `kompile` script should be run from the directory where the definition
resides.

Assuming the above suggestions were followed, to compile the untyped version 
of the simple language mentioned above, execute

  kompile simple-untyped

in the `examples/research/simple/untyped` directory.


# How It Works

We recommend the K overview paper

  An overview of the K semantic framework
  Grigore Rosu, Traian-Florin Serbanuta
  Journal of Logic and Algebraic Programming, Volume 79(6), pp 397-434. 2010 
  http://dx.doi.org/10.1016/j.jlap.2010.03.012

for a broader understanding of K.  Here we only discuss how our current K
prototype works, reminding the reader important facts about K in general on
a by-need basis.

In order to actually interpret or analyze programs using a semantics written in
K, there needs to be a way to give the programs to the tool.  Currently, the tool uses the syntax module of a definition to generate a parser for that definition which can be used to parse programs and turn them into their corresponding K AST format.  We briefly outline the process below.

(For examples, see the language examples in the /examples directory;
in particular, /examples/languages/research/simple/untyped is
familiar and well-documented.)

## Parsing Programs

You may prefer to first define the syntax and then the semantics.
That is how most of the languages in the examples directory are defined.
This reduces ambiguities in the parser and therefore might be able to 
parse more programs.
For example, suppose that we want to define a language LANGUAGE and that
we have already defined its syntax in a module LANGUAGE-SYNTAX.
Before even attempting to define the semantics, it is a good idea
to test the syntax by parsing a large variety of programs.

In the examples provided with the tool, programs are in general kept into a `programs` directory in the directory containing the syntax definition.  Their extension is usually an indicator of the definition they belong to.  For example, the /examples/languages/research/simple/untyped/programs contains programs for the simple-untyped definition, among which `factorial.simple` looks like this:

      var x;
      function f(y) {
        var t=1;
        for i = 1 to y do
          t = t*i;
        return t;
      }
      function main() {
        x = 5;
        write(f(x));
      }

If you would like to know more about how to get an external parser to work with K, please contact us at info@k-framework.org .

As explained in the overview paper mentioned above, the entire language
syntax is automatically included as constructors for the builtin sort
K of computation structures, or simply just computations.  Recall (see
the same paper) that syntax plays no special role in K; that is, the
application of the semantic rules takes into account only the structure
of the configuration, and not how the particular current program or
fragment of program is parsed.  That means, in particular, that the
distinction between concrete/abstract syntax and its representation
as computations of sort K is irrelevant in the theory of K.  However,
it becomes quite relevant in implementations of K tools, because we want
to use the defined language syntax as much as possible in the semantics,
which means that we need to combine a parser for the defined language
with a parser for K in order to parse the semantic rules, which is a
non-trivial engineering endeavor.

In our current implementation of K, the internal representation of the
syntactic terms follows the simple abstract-syntax-tree (AST) syntax:

  K ::= KLabel(List{K})

List{K} is a non-terminal standing for lists of K terms separated by
double-comma ",," (we chose double-comma to avoid conflicts with
user-defined language syntax, for example comma).  We use ".List{K}"
for the unit of List{K}.  This way, from an internal representation
point of view, a language syntax is nothing but a finite set of KLabel
constants.  The `kast` program can be used to parse a program and see its K ast form.  By running

  kast -lang simple-untyped programs/factorial.simple

one obtains the folowing internal representation of the above program:

  '__('var_;('_`,_(# #id_("x")(.List{K}),,'.List`{","`}(.List{K}))),,
  '__('function_`(_`)_(# #id_("f")(.List{K}),,'_`,_(# #id_("y")(.List{K}),,
  '.List`{","`}(.List{K})),,'`{_`}('__('var_;('_`,_('_=_(# #id_("t")(.List{K}),,
  # 1(.List{K})),,'.List`{","`}(.List{K}))),,'__('`{_`}('__('var_;('_`,_(
  # #id_("i")(.List{K}),,'.List`{","`}(.List{K}))),,'__('_;('_=_(# #id_("i")(
  .List{K}),,# 1(.List{K}))),,'while_do_('_<=_(# #id_("i")(.List{K}),,
  # #id_("y")(.List{K})),,'`{_`}('__('_;('_=_(# #id_("t")(.List{K}),,'_*_(
  # #id_("t")(.List{K}),,# #id_("i")(.List{K})))),,'_;('_=_(# #id_("i")(
  .List{K}),,'_+_(# #id_("i")(.List{K}),,# 1(.List{K})))))))))),,'return_;(
  # #id_("t")(.List{K})))))),,'function_`(_`)_(# #id_("main")(.List{K}),,
  '.List`{","`}(.List{K}),,'`{_`}('__('_;('_=_(# #id_("x")(.List{K}),,# 5(
  .List{K}))),,'write`(_`);('_`(_`)(# #id_("f")(.List{K}),,'_`,_('_`(_`)(
  # #id_("f")(.List{K}),,'_`,_(# #id_("x")(.List{K}),,'.List`{","`}(
  .List{K}))),,'.List`{","`}(.List{K})))))))))

Our current implementation allows you to use either concrete syntax
or abstract syntax (as above) in your semantic rules.  We typically prefer
the concrete syntax, but you may need to use the abstract syntax instead
when your syntax confuses our current (simplistic) parser.  

## Running Programs

The `krun` tool can be used to execute programs, or explore their behaviors.
What the `krun` tool basically does is (1) to put the internal representation of the program in the initial configuration described in the definition; (2) to call the rewrite engine to execute the program b rewriting the thus obtained initial configuration; and (3) to post-process the output of the rewrite engine and display it in a more appealing format.

The idea now is that we can use the K tool to compile LANGUAGE, and
then use `krun` to execute the program using the semantics.
To run our sample program `factorial`, all we need to do is something
like this:

  $ kompile simple-untyped.k
  $ krun programs/factorial.simple
  6689502913449127057588118054090372586752746333138029810295671352301633557244962989366874165271984981308157637893214090552534408589408121859898481114389650005964960521256960000000000000000000000000000


If, instead, one wants to search for all possible final states which
could be obtained upon running the program, then one would need to use
the command

  $ krun programs/factorial.simple

And we get the result:

  Solution 1, state 891:
  Final:Bag --> < T > < out > ListItem(Int 120(.List{K})) </ out > ... </ T >

  No more solutions.
  states: 28416 rewrites: 224454 in 3093ms cpu (3095ms real)
  (72555 rewrites/second)

Similarly, if you want to model check a non-deterministic or concurrent
program, then you can use Maude's builtin LTL model-checker.  In order to do
that, you need to define state predicates (or better say configuration
predicates).  This is a bit technical but it follows Maude's approach
ad literam, so we do not explain it here.  The reader is refered to Maude's
manual for more information on how to use its LTL model-checker, and again to 
simple/untyped for an example (showing how to model-check Dekker's algorithm).

Important note: when defining programming languages with concurrency and/or
with constructs evaluating their arguments in non-deterministic order, the
state-space to be searched can be huge.  To reduce the state-space, you can
limit the amount of non-determinism by saying explicitly which rules you want
to count as transitions, which operations should start superheating the computation, and which should cool down the computation to enable a different expression to be scheduled for evaluation.  This is done by associating tags to rules or operations, and then kompiling the definition with certain options
stating which tags count as transitions and which as non-deterministic steps.
See, again, the simple/untyped example (the Makefile shows the kompile options).


# Reporting Issues/Bugs/Feature requests

Please report issues here: http://k-framework.googlecode.com, under "issues".
Simply post your test case and briefly explain your problem.  If you have
write permissions to our repository, please also add a test case to the
repository yourself using the directions in "tests/issues/README" (do this
in addition to posting an issue, because you need the issue number).
