# Overview

K is an executable semantic framework in which programming languages, calculi,
as well as type systems or formal analysis tools can be defined by making use of
configurations, computations and rules.
- Configurations organize the system/program state in units called cells,
  which are labeled and can be nested.  
- Computations carry "computational meaning" as special nested list structures 
  sequentializing computational tasks, such as fragments of program; in 
  particular, computations extend the original language or calculus syntax.  
- K (rewrite) rules generalize conventional rewrite rules by making it explicit 
  which parts of the term they read-only, write-only, or do not care about. This 
  distinction makes K a suitable framework for defining truly concurrent 
  languages or calculi even in the presence of sharing.

Since computations can be handled like any other terms in a rewriting
environment, that is, they can be matched, moved from one place to another in
the original term, modified, or even deleted, K is particularly suitable for
defining control-intensive language features such as abrupt termination,
exceptions, call/cc, concurrency, etc.

## The K Prototype

The k-framework.googlecode project, also called the "K prototype" from here on,
is a prototype implementation of the K Framework written in Maude and using
Maude to give a rewriting executable semantics to K definitions.

The K prototype is developed by a joint team of faculty and students from the
University of Illinois at Urbana-Champaign (the FSL group, led by professor
Grigore Rosu), and University Alexandru Ioan Cuza, Iasi, Romania (the FMSE
group, led by professor Dorel Lucanu).

A current list of the people involved in the project and their specific roles
can be accessed at http://code.google.com/p/k-framework/people/list.


# Installation

As the tool is still a research prototype, the easiest way to run it is to use
the virtual machine we provide at:

  https://code.google.com/p/k-framework/wiki/Downloads

If you would rather install the tool on your machine directly, please see the 
INSTALL file for detailed installation instructions.


# Usage

The languages defined so far using the K framework can be found in the examples
directory. For example, the directory

  examples/languages/research/simple 

contains 2 directories, namely "untyped" containing the definition of the
untyped version of the language, and "typed" which in turn contains three
directories with definitions: "static", for the static semantics, i.e., the type
checker; "dynamic", for the dynamically typed version of simple; and
"dynamic-typed-locations" which is a variant of dynamic, in which the type
information is maintained in the environment.

We encourage you to contribute with examples to our distribution.  Please see
examples/README for instructions on how to do it.


# How It Works

We recommend the K overview paper:

  An overview of the K semantic framework Grigore Rosu, Traian-Florin Serbanuta
  Journal of Logic and Algebraic Programming, Volume 79(6), pp 397-434. 2010
  http://dx.doi.org/10.1016/j.jlap.2010.03.012

for a broader understanding of K.  Here we only discuss how our current K
prototype works, reminding the reader important facts about K in general on a
by-need basis.

In order to actually interpret or analyze programs using a semantics written in
K, there needs to be a way to give the programs to the tool.  Currently, the
tool uses the syntax module of a definition to generate a parser for that
definition which can be used to parse programs and turn them into their
corresponding K-AST (KAST) format.  We briefly outline the process below.

For examples, see the language examples in the /examples directory; in
particular, /examples/languages/research/simple/untyped is familiar and
well-documented.

## Parsing Programs

You may prefer to first define the syntax and then the semantics.  That is how
most of the languages in the examples directory are defined.  This reduces
ambiguities in the parser and therefore might be able to parse more programs.
For example, suppose that we want to define a language LANGUAGE and that we have
already defined its syntax in a module LANGUAGE-SYNTAX.  Before even attempting
to define the semantics, it is a good idea to test the syntax by parsing a large
variety of programs.

In the examples provided with the tool, programs are generally kept in a
`programs` directory in the directory containing the syntax definition.  Their
extension is usually an indicator of the definition they belong to.  For
example, the /examples/languages/research/simple/untyped/programs directory 
contains programs for the simple-untyped definition.

As explained in the overview paper mentioned above, the entire language syntax
is automatically included as constructors for the builtin sort K of computation
structures, or simply just computations.  Recall (see the same paper) that
syntax plays no special role in K; that is, the application of the semantic
rules takes into account only the structure of the configuration, and not how
the particular current program or fragment of program is parsed.  That means, in
particular, that the distinction between concrete/abstract syntax and its
representation as computations of sort K is irrelevant in the theory of K.
However, it becomes quite relevant in implementations of K tools, because we
want to use the defined language syntax as much as possible in the semantics,
which means that we need to combine a parser for the defined language with a
parser for K in order to parse the semantic rules.  If you would like to know 
more about how to get an external parser to work with K, please contact us at 
info@k-framework.org .

In our current implementation of K, the internal representation of the syntactic
terms follows the simple abstract-syntax-tree (AST) syntax:

  K ::= KLabel(List{K})

List{K} is a non-terminal standing for lists of K terms separated by
double-comma ",," (we chose double-comma to avoid conflicts with user-defined
language syntax, for example comma).  We use ".List{K}" for the unit of List{K}.
This way, from an internal representation point of view, a language syntax is
nothing but a finite set of KLabel constants.  The `kast` program can be used to
parse a program and see its KAST form.  By running

  $ kast --k-definition=simple-untyped programs/diverse/factorial.simple

from the /examples/languages/research/simple directory, one obtains the internal
representation of the factorial program:

  '__('function_`(_`)_(# #id_("factorial")(.List{K}),,'_`,_(# 
  #id_("y")(.List{K}),,'.List`{","`}(.List{K})),,'`{_`}('__('var_;('_`,_('_=_
  (# #id_("t")(.List{K}),,# 
  1(.List{K})),,'.List`{","`}(.List{K}))),,'__('print`(_`);('_`,_(# 
  "Factorial of "(.List{K}),,'_`,_(# #id_("y")(.List{K}),,'_`,_(# " is: 
  "(.List{K}),,'.List`{","`}(.List{K}))))),,'__('`{_`}('__('var_;('_`,_('_=_
  (# #id_("i")(.List{K}),,# 
  1(.List{K})),,'.List`{","`}(.List{K}))),,'while_do_('_<=_(# 
  #id_("i")(.List{K}),,# #id_("y")(.List{K})),,'`{_`}('__('_;('_=_(# 
  #id_("t")(.List{K}),,'_*_(# #id_("t")(.List{K}),,# 
  #id_("i")(.List{K})))),,'_;('_=_(# #id_("i")(.List{K}),,'_+_(# 
  #id_("i")(.List{K}),,# 1(.List{K}))))))))),,'return_;(# 
  #id_("t")(.List{K}))))))),,'function_`(_`)_(# 
  #id_("main")(.List{K}),,'.List`{","`}(.List{K}),,'`{_`}('__('print`(_`); 
  ('_`,_(# "Input a natural number: 
  "(.List{K}),,'.List`{","`}(.List{K}))),,'print`(_`);('_`,_('_`(_`)(# 
  #id_("factorial")(.List{K}),,'_`,_('read`(`)(.List{K}),,'.List`{","`}
  (.List{K}))),,'_`,_(# "\n"(.List{K}),,'.List`{","`}(.List{K})))))))) 

Typically, one does not need to run the `kast` program directly, as it will be
run by the `krun` program (below) when necessary.  However, running it directly
can be useful to test your syntax.

Our current implementation allows you to use either concrete syntax or abstract
syntax (as above) in your semantic rules.  We typically prefer the concrete
syntax, but you may need to use the abstract syntax instead when your syntax
confuses our current (simplistic) parser.


## Running Programs

The `krun` tool can be used to execute programs, or explore their behaviors.
What the `krun` tool basically does is (1) to put the internal representation of
the program in the initial configuration described in the definition; (2) to
call the rewrite engine to execute the program by rewriting the thus obtained
initial configuration; and (3) to post-process the output of the rewrite engine
and display it in a more appealing format.

The idea now is that we can use the K tool to compile LANGUAGE, and then use
`krun` to execute the program using the semantics.  To run our sample program
`factorial`, all we need to do is something like this:

  $ kompile simple-untyped.k
  $ krun --no-config programs/diverse/factorial.simple
  Input a natural number: 5
  Factorial of 5 is: 120

The --no-config option tells krun not to display the configuration.  Instead, it
only displays output produced by the program.  Try running it without this
option to see the resulting configuration.

If instead of executing, one wants to search for all possible final states which
could be obtained upon running the program, then one would need to use the 
command:

  $ echo "5" | krun --search programs/diverse/factorial.simple

And we get the result:
  Search results:
  
  Solution 1, state 51:
  <T> 
    ...
    <out> "Input a natural number: Factorial of 5 is: 120\n" </out>
	... 
  </T>

  No more solutions.

Similarly, if you want to model check a non-deterministic or concurrent program,
then you can use Maude's builtin LTL model-checker.  In order to do that, you
need to define state predicates (more appropriately called configuration 
predicates).  This is a bit technical but it follows Maude's approach ad 
literam, so we do not explain it here.  The reader is refered to Maude's manual 
for more information on how to use its LTL model-checker, and again to
simple/untyped for an example (showing how to model-check Dekker's algorithm).

Important note: when defining programming languages with concurrency and/or with
constructs evaluating their arguments in non-deterministic order, the
state-space to be searched can be huge.  To reduce the state-space, you can
limit the amount of non-determinism by saying explicitly which rules you want to
count as transitions, which operations should start superheating the
computation, and which should cool down the computation to enable a different
expression to be scheduled for evaluation.  This is done by associating tags to
rules or operations, and then kompiling the definition with certain options
stating which tags count as transitions and which as non-deterministic steps.
See, again, the simple/untyped example (the Makefile shows the kompile options).


# Reporting Issues/Bugs/Feature requests

Please report issues here: http://k-framework.googlecode.com, under "issues".
Simply post your test case and briefly explain your problem.  If you have write
permissions to our repository, please also add a test case to the repository
yourself using the directions in "tests/issues/README" (do this in addition to
posting an issue, because you need the issue number).
