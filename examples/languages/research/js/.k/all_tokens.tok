>=Int $instanceof $switch #closing #if #charString $inf #eval #istream $case =/=K .AttributeSet $comma ^Int $block <=List #Nat >Nat #LTLFormulaList .Rec true $initNewId $u LTL|-> $break <Qids> #then #connected <=Float >>Nat $catch $assignment #removeCharUponAck $for .None LTL<-> #closeSocket #receive #finished <=Nat = #TCPState #FiniteFloat #Qid $nop =/=Bool LTL/\ #isTCPError $lt ==List #Transition and-then <= *Nat #String #peekByte() $try $TypeError #createServerTcpSocket <=Rat +String * LTL~ %Int <Float #TransitionList LTL; undef/ #acceptClient #ostream $identical #containedRequest -Float #Bool >=Float #open #reopen .Empty #peekByte $gte #start #createClientTcpSocket LTL-> #seek $this $compoundAssignment ==Bool LTL=> .List /Nat LTL$invert #haveAnswer ==KLabel $obj ==Bag &Int LTL<> ^Nat -Int $continue #receiving #stderr ==String $ifElse </ @latex #connecting .Bag $new ==Float $lte $and LTL<=> *Int $program =/=String #checkResult < .Set $label $n $return >Int $while $invoke $varDeclarations -> #Rat $or >Float |Nat =/=Bag #socketError $env #sending >=String #close #fReadChar #retrieveTCPError <Rat $in $div $sub #NzInt $propertyLit #readChar() #state: $default / $b $forIn .Map ==Int +Float ~> #checkTCPAnswer #DecFloat List{KResult} <<Int .K $id $exp +Int #errorTCPSyntax $stmts $add $rec >=Nat #createdSocket #tcpError #idle #fPrintChar #putByte #EOF $typeof #Zero $arrayLit -Set or-else #acceptedClient answer: #fReadByte $neg #NzRat $hasMapping $null ==Set #closedSocket #Float >>Int $dynamicAccess +Rat <Int #else <=Int <Nat =/=Float #fPutByte $ReferenceError ^Float 'wrap-with $objectLit false #RuleName >String =/=Int #fPeekByte $notIdentical #Int $gt =/=List #LTLFormula *Rat !=Int LTL|= ==K ? ^Rat #eof #Char NeList{KResult} %Nat #fi -Rat #connectedTo: NeList{K} #ModelCheckResult ==Universal : #stdin #convertToken #ioError <=Set .List{K} k-result $mul LTL\/ => $not $do =/=Set #eof() $dec $ternary %Float >=Rat #parse <Strings> $z #checkAnswer #readChar #fEof $staticAccess <=Bag $function #PosRat $regex =/=KLabel #TautCheckResult ...</ | >... <<Nat #buffer |Int #tcpRequest *Float $binding id: #isDigit /Rat -Bag =/=CellLabel #readByte() #sent + #id #error #NzNat #checkAnswer-aux ~Int <String #Id #socketManager /Int #Socket $inc wrap-with /Float $sameAs $notSameAs .Configuration ==CellLabel #noIO ##tcpRequest $f $plus #isWhiteSpace $s > #printChar #string2Int $throw $labelledStmt =/=Universal --Int #send &Nat #readByte <Floats> #received #getTCPData +Nat $nan $mod #tell List{K} >Rat |-> $delete . <=String #toSend #TCPPORT <> #stdout #flush #socket
   ==Bool   =/=Bool   andBool   orBool   xorBool  notBool   impliesBool   orElseBool   andThenBool  '#andBool    +Int   -Int   *Int   /Int   %Int   <=Int   <Int   >=Int   >Int   ==Int   =/=Int  dummyNat isNat     dividesInt  absInt  maxInt      minInt       <<Int   >>Int   &Int   |Int   ^Int   xorInt  ~Int  Bool2Int       +Float   -Float   *Float   /Float   %Float   <=Float   <Float   >=Float   >Float   ==Float   =/=Float  Int2Float    Float2Int    sqrtFloat    logFloat    expFloat    atanFloat    acosFloat    asinFloat    tanFloat    cosFloat    sinFloat    atan2Float      floorFloat         +String   ==String  lengthString    charString    asciiString    substrString        Float2String    String2Float    String2Int    Int2String    Id2String    String2Id    String2Rat      Rat2String       =/=String  dummyChar isChar    #isWhiteSpace    #isDigit    #if #then #else #fi  ==K   =/=K   <=List   ==List   =/=List   <=Set   ==Set   =/=Set   <=Bag   ==Bag   =/=Bag   ==List K    =/=List K    ==KLabel   =/=KLabel   ==CellLabel   =/=CellLabel  #EOF   #tcpError    #tcpRequest    #checkTCPAnswer    ##tcpRequest    #retrieveTCPError    #isTCPError    randomRandom          #open    #reopen      #close    #fEof    #tell    #seek      #fPeekByte    String2Bool    #ioError    #fPutByte      #flush    #fReadByte    String2DotK    #stdin #stdout #stderr #readByte   #peekByte   #putByte    #eof   #string2Int    #readChar   #fReadChar    #charString    #printChar    #fPrintChar      #removeCharUponAck #parse      #convertToken      #buffer    #istream    #ostream    #noIO                 $n    $f    $z    $inf    $nan sign    finiteValue    $u $null $b    $s    boolValue    stringValue    .None $binding      $regex    $ReferenceError    $TypeError    .Rec $rec    $obj    $env      $id    .Empty $this $nop $initNewId      $staticAccess      $dynamicAccess      $invoke      $new    $inc      $dec      $delete    $typeof    $not    $neg    $plus    $mul      $div      $mod      $add      $sub      $lt      $lte      $gt      $gte      $in      $instanceof      $sameAs      $notSameAs      $identical      $notIdentical      $and      $or      $ternary        $assignment      $compoundAssignment        $arrayLit    $objectLit    $propertyLit      $return    $break    $continue    $throw    $label      $exp    $stmts    $block    $comma    $ifElse        $try        $catch      $case      $default    $switch        $for          $forIn        $while      $do      $labelledStmt      $varDeclarations    $function          $program        isKeyPresent      isKeyAbsent      discard replaceResult    jsType    typeof    isTruthy    isFinite    notNan    isNumber    notNumber    isString    notString    isBinding    notBinding    toPrimitive      toBoolean    toNumber    toString    toObject    asObject    checkObjectCoercible    if        hasRecProperty      hasNoRecProperty      getRecValueIfAbsent        getEnsuredRecValue      copyRecWithValue        copyRecWithoutProperty      hasProperty      hasNoProperty      newObj allocNewRec getEnsuredPropertyValue      getPropertyValueIfAbsent        getPropertyValue      setPropertyValue        deleteProperty      resolveIdentifier      getTarget    getPropertyName    getValue    putValue      not    neg    arith        newSign      newInfinity      newZero      strAdd      add      postOp        preOp        comparison      lessThan      identical      castEqual      accessPropertyAt      varPreDeclarations    varPreDeclaration    funcPreDeclarations    assignmentExp        program1 program2 program3 program4 programEx1 programEx3 programEx4 programEx5 initJS initGlobalLexEnv    initUndefined run    go   