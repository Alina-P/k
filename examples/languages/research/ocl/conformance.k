require ocl-semantics


module CONFORMANCE is including OCL-SEMANTICS

/*
kvar INSTANCES REST B RESTBAG RESTINSTANCES : Bag
kvar ATTRCLS ATTRINST Map Map' Map'' : Map 
kvar C T nm INSNAME attr x : Id 
kvar OCL : List
kvar E : Exp
kvar v : Val
*/

syntax K ::= "checkConformance"


rule <k> checkConformance => checkOCL(OCL) ...</k> 
	 <oclConstraints> OCL:List => . </oclConstraints> [structural]



syntax K ::= "checkStructure" "(" Bag ")"

rule <k> checkStructure(.Bag) => . ...</k>  [structural]

syntax K ::= "pause"

rule <k> checkStructure((<instance>... 
							<attributes> ATTRINST:Map </attributes>
							<ofClass> C:#Id </ofClass>  ...</instance>) REST:Bag)
         => 
   consistentAttributes(ATTRINST:Map, attributeDecl(C:#Id))~>checkStructure(REST:Bag) ...</k>  [structural]


syntax K ::= "consistentAttributes" "("  Map , Map ")"

rule <k> consistentAttributes( .Map, _ ) => .K ...</k>  [structural]


// for basic types : just check that the attribute is declared in metamodel
rule  <k> consistentAttributes( (attr:#Id |->  typedElt(v:#Magma,T:#Id)) Map':Map, 
                                (attr:#Id |-> T:#Id ) Map'':Map)
      =>
      consistentAttributes(Map':Map,Map'':Map) ...</k>
      when isBasic(T:#Id)  [structural]


//for enumerations : check that the attribute is declared with same enum type; check value
//assumption (made in metamodels) : no class and enum have same name
 rule  <k> consistentAttributes( attr:#Id |->  typedElt(x:#Magma,T:#Id) Map':Map, attr:#Id |-> T:#Id Map'':Map)
      => consistentAttributes(Map':Map, Map'':Map) ...</k>
      when isEnum(T:#Id) andBool (x:#Magma in values(T:#Id))  [structural]

// isEnum, values : generated by Rascal in META-MODEL


// for classes or collections : check that instances are also 
// in the model and are of the correct (declared) type
rule  <k> consistentAttributes(
							(attr:#Id |->  typedElt(v:#Magma,T:#Id) Map':Map) ,  //T here may be a subtype of
                            (attr:#Id |-> T:#Id  Map'':Map))   // T here
      => ( allPresentAndWellTyped(v:#Magma) ~> consistentAttributes(Map':Map, Map'':Map) ) ...</k>
      when notBool (isBasic(T:#Id) orBool isEnum(T:#Id)) [structural]



syntax #Bool ::= "isBasic" "(" #Id ")"

rule isBasic(int) => true [structural]
rule isBasic(bool) => true [structural]
rule isBasic(string) => true [structural]
rule isBasic(C:#Id) => false when (( C:#Id =/=Bool int) andBool (C:#Id =/=Bool bool) andBool  (C:#Id =/=Bool string)) [structural]




syntax K ::= "allPresentAndWellTyped" "(" #Magma ")"

// all elements in a collection must exist  among instances 

rule <k> allPresentAndWellTyped(.Magma) => .K ...</k>  [structural]

rule <k> allPresentAndWellTyped(INSNAME:#MagmaElement ;Magma RESTMAP:#Magma) => allPresentAndWellTyped(RESTMAP:#Magma) ...</k>
	<instances>... 
	   <instance>...
			<instName> INSNAME </instName>
			<ofClass> T </ofClass>
	   ...</instance>
	...</instances>  [structural]


syntax K ::= "checkOCL" "(" List ")"

rule <k> checkOCL(.List) => .K ...</k>   [structural]

syntax ListItem ::= "OCL" "(" Exp ")" 
				  | "result" "(" #Magma ")"

rule <k> checkOCL( OCL(E:Exp) L:List) => E ~> checkOCL(L) ...</k>   [structural]
// when an expression finished evaluating, it is placed at the end of the ocl constraints list

// comment  when "executing" a model
rule <k> v => .K ...</k>
	 <trace>... .List => result(v) </trace> [structural]


end module
