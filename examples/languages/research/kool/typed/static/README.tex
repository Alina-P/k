\setlength{\parindent}{1em}
\title{KOOL --- Typed --- Static}
\author{Grigore Ro\c{s}u and 
        Traian Florin \c{S}erb\u{a}nu\c{t}\u{a}
        (\texttt{\{grosu,tserban2\}@illinois.edu})}
\organization{University of Illinois at Urbana-Champaign}

\maketitle

\begin{kblock}[text]
\section{Abstract}
This is the \K static semantics of the typed KOOL language.
It extends the static semantics of typed SIMPLE with static semantics
for the object-oriented constructs.  Also, the static semantics of
some of the existing SIMPLE constructs need to change, in order to
become more generous with regards to the set of accepted programs,
mostly due to subtyping.  For example, the assignment construct
``\texttt{x = e}'' required that both the variable \texttt{x} and the
expression \texttt{e} had the same type in SIMPLE\@.  In KOOL, the type
of \texttt{e} can be a subtype of the type of \texttt{x}.
Specifically, we define the following typing policy for KOOL,
everything else not mentioned below borrowing its semantics from
SIMPLE:
\begin{itemize}
\item Each class \texttt{C} yields a type ``\texttt{class C}'', which
can be explicitly used in programs to type variables and methods,
possibly in combination with other types.
\item Since now we have user-defined types, we check that each type
used in a KOOL program is well-formed, that is, it is constructed only
from primitive and class types corresponding to declared classes.
\item Class members and their types form a {\em class type
environment}.  Each class will have such a type environment.
Each member in a class is allowed to be declared only once.  Since in
KOOL we allow methods to be assigned to fields, we make no distinction
between field and method members; in other words, we reject programs
declaring both a field and a method with the same name.
\item If an identifier is not found in the local type environment, it
will be searched for in the current class type environment.  If not
there, then it will be searched for in its superclass' type
environment.  And so on and so forth.  If not found until the
\texttt{object} class is reached, a typing error is reported.
\item The assignment allows variables to be assigned values of
more concrete types.  The result type of the assignment expression
construct will be the (more abstract) type of the assigned variable,
and not the (more concrete) type of the expression, like in Java.
% explain why is that?
\item Exceptions are changed (from SIMPLE) to allow throwing and
catching only objects, like in Java.  Also, unlike in SIMPLE, we do
not check whether the type of the thrown exception matches the type of
the caught variable, because exceptions can be caught by other
\texttt{try/catch} blocks, even by ones in other methods.  To avoid
having to annotate each method with what exceptions it can throw, we
prefer to not check the type safety of exceptions (although this is an
excellent homework!).  We only check that the \texttt{try} block
type-checks and that the \texttt{catch} block type-checks after we bind
the caught variable to its claimed type.
\item Class declarations are not allowed to have any cycles in their
extends relation.  Such cycles would lead to non-termination of
\texttt{new}, as it actually does in the dynamic semantics of KOOL
where no such circularity checks are performed.
\item Methods overriding other methods should be in the right subtyping
relationship with the overridden methods: co-variant in the codomain
and contra-variant in the domain.
\end{itemize}

\end{kblock}

\vspace*{3ex}
