\setlength{\parindent}{1em}
\title{KOOL --- Untyped}
\author{Grigore Ro\c{s}u and 
        Traian Florin \c{S}erb\u{a}nu\c{t}\u{a}
        (\texttt{\{grosu,tserban2\}@illinois.edu})}
\organization{University of Illinois at Urbana-Champaign}

\maketitle

\begin{kblock}[text]
\section{Abstract}
This is the \K semantic definition of the untyped KOOL language.
KOOL is aimed at being a pedagogical and research language that
captures the essence of the object-oriented programming paradigm.
Its untyped variant discussed here is simpler than the typed one,
ignoring several intricate aspects of types in the
presence of objects.  A program consists of a set of class declarations.
Each class can extend at most one other class (KOOL is single-inheritance).
A class can declare a set of fields and a set of methods, all public and
called the class' \textit{members}.
Specifically, KOOL includes the following features:
\begin{itemize}
\item Class declarations, where a class may or may not extend another class.
In case a class does not explicitly extend another class, then it is assumed
that it extends the default top-most and empty (i.e., no members)
class called \texttt{object}.  Each class is required to declare precisely one
homonymous method, called its \textit{constructor}.  Each valid
program should contain one class named \texttt{main}, whose
constructor, \texttt{main()}, takes no arguments.  The execution of a
program consists of creating an object instance of class \texttt{main}
and invoking the constructor \texttt{main()} on it, that is, of
executing ``\texttt{new main();}''.
\item All features of SIMPLE (see
{\footnotesize\texttt{examples/languages/research/simple/untyped}}),
that is, multidimensional arrays, function (here called ``method'')
abstractions with call-by-value parameter passing style and static
scoping, blocks with locals, input/output, parametric exceptions, and
concurrency via dynamic thread creation/termination and synchronization.  
The only change in the syntax of SIMPLE when imported in KOOL is the
function declaration keyword, \texttt{function}, which is changed into
\texttt{method}.  The exact same desugaring macros from SIMPLE are
also included in KOOL.  We can think of KOOL's classes as embedding
SIMPLE programs (extended with OO constructs, as discussed next).
\item Object creation using the ``\texttt{new C(e1,...,en)}'' expression
construct.  An object instance of class \texttt{C} is first created and then
the constructor \texttt{C(e1,...,en)} is implicitly called on that
object.  KOOL only allows (and requires) one constructor per class.
The class constructor can be called either implicitly during a new
object creation for the class, or explicitly.  The superclass
constructor is {\em not} implicitly invoked when a class constructor
is invoked; if you want to invoke the superclass constructor from a
subclass constructor then you have to do it explicitly.
\item An expression construct \texttt{this}, which evaluates to the current
object.
\item An expression construct \texttt{super}, which is used (only) in
combination with member lookup (see next) to refer to a superclass field or
method.
\item A member lookup expression construct \texttt{e.x}, where \texttt{e}
is an expression (either an expression expected to evaluate to an object
or the \texttt{super} construct) and \texttt{x} is a class member name,
that is, a field or a method name.
\item Expression constructs ``\texttt{e instanceOf C}'' and
``\texttt{cast e to C}'', where \texttt{e} is an expression expected
to evaluate to an object and \texttt{C} a class name.  The former
tells whether the class of \texttt{e} is a subclass of \texttt{C},
that is, whether \texttt{e} can be used as an instance of \texttt{C},
and the latter changes the class of \texttt{e} to \texttt{C}.  These
operations always succeed: the former returns a Boolean value, while
the latter changes the current class of \texttt{e} to \texttt{C}
regardless of whether it is safe to do so or not.  The typed version
of KOOL will check the safety of casting by ensuring that the instance
class of the object is a subclass of \texttt{C}.  In untyped KOOL we
do not want to perform this check because we want to allow the
programmer maximum of flexibility: if one always accesses only
available members, then the program can execute successfully despite
the potentially unsafe cast.
\end{itemize}

There are some specific aspects of KOOL that need to be discussed.

First, KOOL is higher-order, allowing function abstractions to be
treated like any other values in the language.  For example, if
\texttt{m} is a method of object \texttt{e} then \texttt{e.m}
evaluates to the corresponding function abstraction.  The function
abstraction is in fact a closure, because in addition to the method
parameters and body it also encapsulates the object value (i.e., the
environment of the object together with its current class---see below)
that \texttt{e} evaluates to.  This way, function abstractions can be
invoked anywhere and have the capability to change the state of their
object.  For example, if \texttt{m} is a method of object \texttt{e}
which increments a field \texttt{c} of \texttt{e} when invoked, and if
\texttt{getm} is another method of \texttt{e} which simply returns
\texttt{m} when invoked, then the double application
\texttt{(e.getm())()} has the same effect as \texttt{e.m()}, that is,
increments the counter \texttt{c} of \texttt{e}.  Note that the
higher-order nature of KOOL was not originally planned; it came as a
natural consequence of evaluating methods to closures and we decided
to keep it.  If you do not like it then you should not use it.

Second, since all the fields and methods are public in KOOL and since
they can be redeclared in subclasses, it is not immediately clear how
to lookup the member \texttt{x} when we write \texttt{e.x} and
\texttt{e} is different from \texttt{super}.  We distinguish two cases,
depending on whether \texttt{e.x} occurs in a method invocation
context (i.e., \texttt{e.x(...)}) or in a field context.  KOOL has
dynamic method dispatch, so if \texttt{e.x} is invoked as a method
then \texttt{x} will be searched for starting with the instance class of
the object value to which \texttt{e} evaluates.  If \texttt{e.x}
occurs in a non-method-invocation context then \texttt{x} will be
treated as a field (although it may hold a method closure due to the
higher-order nature of KOOL) and thus will be searched starting with
the current class of the object value of \texttt{e} (which, because of
\texttt{this} and casting, may be different from its instance class).
In order to achieve the above, each object value will consist of a
pair holding the current class of the object and an environment stack
with one layer for each class in the object's instance class hierarchy.

Third, although KOOL is dynamic method dispatch, its capabilities
described above are powerful enough to allow us to mimic static
method dispatch.  For example, suppose that you want to invoke method
\texttt{m()} statically.  Then all you need to do is to declare a
local variable and bind it to \texttt{m}, for example ``\texttt{var
staticm = m;}'', and then call \texttt{staticm()}.  This works because
\texttt{staticm} is first bound to the method closure that \texttt{m}
evaluates to, and then looked up as any local variable when invoked.
We only enable the dynamic method dispatch when we have an object
member on an application position, e.g., \texttt{m()}.

In what follows, we limit our comments to the new, KOOL-specific
aspects of the language.  We refer the reader to the untyped SIMPLE
language for documentation on the the remaining features, because
those were all borrowed from SIMPLE.
\end{kblock}

\vspace*{3ex}
