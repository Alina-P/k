--------------------------------------
--- TOOL IMPROVEMENTS AND CONCERNS ---
--------------------------------------

* Slow kompilation
- We know that, let's hope K3 will be faster

* BAD error messages
- We know that and hope that K3 will have better error messages.

* The HOLE [] does not look good in the terminal
- Yes, you have to make sure your client uses the UTF-8 character set.
This is also said on the KVM download page, although people don't read that.
David: there is enough evidence that you should check the UTF-8 capability.

* The --- line for anonymous variables looks strange in non-cell contexts.
- Should we replace it with a normal underscore in those contexts?

* It might be useful if krun had a timer for waiting the input (if
this is expected, but is missing), after a predefined time value, to
stop writing a message like "no input, hence no (k)run"
- I am personally not sure about that.  The current behavior, to wait
for an input indefinitely, is the same behavior that we see in all
programming languages.

* Comments take a lot of space and make the actual semantics hard to
follow in ASCII format.
- I put warnings and comments at the beginning of the ascii.k
definitions on how to deal with these comments.  We currently use the
kpp, which would be very nice to be incorporated in kompile as a
special option, as we discussed.  If the same option is used in
combination with --pdf, then it should generate the PDF without
comments.  Also, we may consider devising K modes for emacs, vim,
notepad++, etc., and make them public.

* It would be nice to have links and be ablke to click and jump in PDFs
- It would, at least within one PDF file.  I am not too optimisitic
that we can make this work well across different PDFs.

* We should get rid of nextLoc, etc.  These are low level and ugly.
- I cannot agree more

* Should we show quotes in the generated PDF, as we do in the .k files?
- I don't know.  We should discuss this together.

* I would like to use contextual rewriting also in lists, e.g.,
rule <k> print((I:#Int => .AExps),_) ...</k>
     <out>... . => ListItem(I) </out>    [transition]
- Me, too :-).  Our current lists are cons-lists, so you cannot
prepend a .AExps in front of them.  I hope this limitation will
dissapear when/if we allow associative lists.

* Can you call them imp++.k, IMP++, IMP++-SYNTAX, etc?
- Of course I tried and kompile gives some errors regarding regular
patterns, etc.  I think it may interpret the + differently.

* Language-specific comments for programs and allow one to declare those in K
- I would be reluctant to do that at this stage.  We have more urgent
things to do.  The conventional comments with /* ... */ and // ...
should be good enough for the time being.

* The default colors displayed by krun are hard to read on white background
- The idea is to have krun display exactly the same colors as in the
configuration declaration.  Now krun also gives us an option to
disable the colors.

* Configuration file for krun, to allow to write options like
  --STATE="stuff" there once and for all.
- We should discuss this when we discuss the .desk files, to see
whether it fits the same idea.

* The tag/labels are displayed alphabetically.
- I know.  They should be displayed in the same order as given.  Traian?

* There is a non-uniformity regarding rule labels versus other tags in
how we write them in the .k file versus how they appear in the PDF
- I personally think that they should all be tags and appear after the
rule.  But some think of a rule label as something special and should
appear in the front.  We should discuss this and reach some consensus.


-------------------------
--- STYLE SUGGESTIONS ---
-------------------------

* You are not consistent with indentation, spacing, where you put the
rule tags, etc.  ... (Then many of you had suggestions on how to do it)
- Actually, I tried very hard to be consistent.  My key number is 2:
2 spaces before all rules, 2 spaces before the production or rule
attributes/tags, 2 whitelines between modules.  When the 2-space rule
makes a line longer than 80 characters, then the tag/attribute goes on
the next line, indented 2 spaces from the "rule" keyword.  The only
time I broke that rule was when it looked much better to allign all
the attributes/tags, like I did with the strictness attributes in syntax.
Please let me know if I break this "2" principle anywhere.

* The order of rules is not clear, seems arbitrary
- I followed the order in the syntax.  When there are more rules for
the same construct, I typically prefer to put the rules in the order
of which they are expected to be applied.  For example, the two rules
for var: I prefer the one with var X,Xs first, because it is the
common case.  Also, and not that this matters in K, in Maude it is
slightly faster to put them this way, because Maude tries them in the
given order.  So the more frequent first means faster.

* Indent comments as well, not only the rules
- I tried and did not like how it looked.  Besides, it is a nightmare
to maintain such comments, because of the 2 spaces.  Maybe there are
editors that allow you to do that more easily, but it is not worth.

* I suggest calling "env" "restoreEnv".  It makes it much easier to
read, especially for someone for whom this is all new.
- We called it restoreEnv a long time ago, but we decided at the time
to change it to env.  Two reasons, as far as I remember: (1) they are
not only used for restoring environments, but setting environments,
too; (2) we wanted at some moment to make this generic, for any cell:
rule <k> cell(C) => . ...</k>  <cell> _ => C </cell>
rule <k> _:KResult ~> (cell(C) => .) ...</k>  <cell> _ => C </cell>

* Consider the idea of forcing users to modify your
definition to run the examples.  The most powerful version
<in color="magenta" stream="stdin"> $IN:List </in>
<out color="Orchid" stream="stdout"> .List </out>
work for all the cases.  Telling the user to swap in and out things
and recompile will confuse them and make them think less of K.
- As discussed also today in the K meeting, this is going to happen
only in the tutorial examples, because I want people to learn how to
use those (cool!) features.  I will add one more warning at the
begining of the imppp.k file.  The actual non-tutorial language
definitions will be configured as generally as possible.
Here are some additional answers on this from the discussions on IMP:
"I did that, but I did not like it in the end, because both cells had
a variable in them and that may make beginners think that that is
necessary in all definitions.  Additionally, it is an interesting and
insightful exercise to change the K definition, rekompile and then
call krun with the --STATE option.  Finally, configuration variables
are not such a common use of K.  It is more like an expert use."


-----------------------
--- SPECIFIC TO IMP ---
-----------------------

* Make it clear that IMP is for beginners, etc.
- We intend to number all definitions in the distribution, to make it clear
in what order people should read them.  IMP will be first.  For that
reason, I also went through several other language definitions and
grabbed stuff that belong here.  For example, I had lots of
explanations about the K framework in SIMPLE, because initially that
was supposed to be the first language people see.


-------------------------
--- SPECIFIC TO IMP++ ---
-------------------------

* IMP++ may sound like an OO version of IMP; maybe a different name?
- Well, we got stuck with this name now, we are not going to change
it.  I'm going to explain better in the overview, or README document
what it does, so people know what to expect.

* Explain better what you mean by non-determinism, as krun is not
non-deterministic
- I added a comment about that in the div-nondet.imp file, as I
thought it fits best there.  Should I add that discussion in the main
imppp.k file?

* Why not adding other constructs as well in IMP++?
- IMP++ is intended to be a minimal extension of IMP including some
constructs which are not easy to define in other languages.  Adding
constructs with repetitive semantics does not help us make the point
better.  Also, IMP++ is kind of fixed now, because I also use it in my
classes in the context of other semantics, which I do not want to
change anymore.
